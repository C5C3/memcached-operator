{
  "feature_id": "MO-0037",
  "title": "J001: Implement secret hash computation and references",
  "slug": "j001-implement-secret-hash-computation-and",
  "status": "completed",
  "phase": "approved",
  "summary": "",
  "description": "**Size:** ðŸ“¦ medium\n**Category:** backend\n**Priority:** critical\n**Source:** Proposed for 'Secret Rotation & Rolling Restart\n\n  Automatic'\n\nCreate `internal/controller/secret.go` with three core functions:\n\n1. `computeSecretHash(secrets ...*corev1.Secret) string` â€” SHA-256 over sorted `.data` keys/values from all referenced Secrets. Must be deterministic and order-independent (sort Secret names, then sort keys within each Secret).\n\n2. `fetchReferencedSecrets(ctx context.Context, client client.Client, mc *v1alpha1.Memcached) ([]*corev1.Secret, []string)` â€” Resolves `SASLSpec.CredentialsSecretRef` and `TLSSpec.CertificateSecretRef` from the Memcached CR. Returns found Secrets and a list of missing Secret names.\n\n3. `mapSecretToMemcached(ctx context.Context, client client.Client) handler.MapFunc` â€” Returns the `EnqueueRequestsFromMapFunc` handler. Lists all Memcached CRs in the Secret's namespace, filters those whose `SASLSpec.CredentialsSecretRef` or `TLSSpec.CertificateSecretRef` match the changed Secret's name, returns `[]reconcile.Request` for matching CRs.\n\nCreate `internal/controller/secret_test.go` with unit tests:\n- Hash determinism (same input â†’ same output)\n- Hash order-independence (secrets in any order â†’ same hash)\n- Hash changes when Secret data changes\n- Empty secrets list returns empty/zero hash\n- `fetchReferencedSecrets` returns found + missing lists correctly\n- `mapSecretToMemcached` only enqueues CRs that actually reference the changed Secret\n- `mapSecretToMemcached` returns empty list for unreferenced Secrets\n\n**Rationale:** Foundation layer that all other features depend on. The hash computation is the core mechanism for detecting Secret changes, and the map function is required for the Secret watch. Without this, no automatic rotation detection is possible â€” users must manually restart Pods after Secret rotation, risking stale credentials/certificates in production.\n\n**Affected Areas:**\n- internal/controller/secret.go\n- internal/controller/secret_test.go",
  "stories": [
    {
      "title": "Operator detects Secret data changes via deterministic hashing",
      "role": "operator",
      "want": "the controller to compute a deterministic SHA-256 hash over all referenced SASL and TLS Secret .data fields",
      "so_that": "any change to Secret content (rotated credentials or certificates) is detected automatically without manual intervention",
      "criteria": [
        "computeSecretHash returns identical output for identical input across multiple invocations",
        "computeSecretHash returns identical output regardless of Secret argument order",
        "computeSecretHash returns identical output regardless of key iteration order within each Secret",
        "computeSecretHash returns a different hash when any Secret .data value changes",
        "computeSecretHash returns empty string when called with zero Secrets"
      ]
    },
    {
      "title": "Controller resolves referenced Secrets from Memcached CR spec",
      "role": "operator",
      "want": "fetchReferencedSecrets to resolve SASLSpec.CredentialsSecretRef and TLSSpec.CertificateSecretRef from the Memcached CR",
      "so_that": "the reconciler has access to the actual Secret objects and knows which Secrets are missing",
      "criteria": [
        "fetchReferencedSecrets returns found Secrets when both SASL and TLS Secret references exist and the Secrets are present",
        "fetchReferencedSecrets returns missing Secret names when a referenced Secret does not exist in the namespace",
        "fetchReferencedSecrets returns empty slices when neither SASL nor TLS is enabled",
        "fetchReferencedSecrets skips SASL ref when Security or SASL spec is nil",
        "fetchReferencedSecrets skips TLS ref when Security or TLS spec is nil"
      ]
    },
    {
      "title": "Secret changes trigger reconciliation of referencing Memcached CRs",
      "role": "operator",
      "want": "a mapSecretToMemcached handler that maps Secret change events to reconcile.Requests for Memcached CRs referencing that Secret",
      "so_that": "when a Secret is updated (e.g. certificate rotation), only the Memcached CRs that reference it are re-reconciled",
      "criteria": [
        "mapSecretToMemcached returns reconcile.Requests only for Memcached CRs whose SASLSpec.CredentialsSecretRef.Name matches the changed Secret",
        "mapSecretToMemcached returns reconcile.Requests only for Memcached CRs whose TLSSpec.CertificateSecretRef.Name matches the changed Secret",
        "mapSecretToMemcached returns empty list when no Memcached CR in the namespace references the changed Secret",
        "mapSecretToMemcached only searches Memcached CRs in the same namespace as the changed Secret",
        "mapSecretToMemcached handles CRs with nil Security spec without panicking"
      ]
    },
    {
      "title": "Operator handles edge cases in Secret hash computation",
      "role": "developer",
      "want": "computeSecretHash to handle edge cases gracefully",
      "so_that": "the hash computation is robust and never panics or produces incorrect results",
      "criteria": [
        "computeSecretHash handles Secrets with nil .data map without panicking",
        "computeSecretHash handles Secrets with empty .data map correctly",
        "computeSecretHash handles duplicate Secret names (same Secret passed twice) deterministically",
        "computeSecretHash handles Secrets with binary data (non-UTF8 values) correctly"
      ]
    },
    {
      "title": "Operator handles edge cases in Secret reference resolution",
      "role": "developer",
      "want": "fetchReferencedSecrets to handle all combinations of enabled/disabled SASL and TLS with present/missing Secrets",
      "so_that": "no combination of CR spec states causes panics or incorrect behavior",
      "criteria": [
        "fetchReferencedSecrets with SASL enabled + Secret exists returns the Secret in found list",
        "fetchReferencedSecrets with SASL enabled + Secret missing returns the name in missing list",
        "fetchReferencedSecrets with TLS enabled + Secret exists returns the Secret in found list",
        "fetchReferencedSecrets with TLS enabled + Secret missing returns the name in missing list",
        "fetchReferencedSecrets with both SASL and TLS referencing the same Secret name returns it once in found list"
      ]
    },
    {
      "title": "Reference documentation covers secret hash and map functions",
      "role": "developer",
      "want": "reference documentation for the new secret.go functions",
      "so_that": "future contributors understand the hash computation algorithm, fetch logic, and map function behavior",
      "criteria": [
        "Documentation explains the SHA-256 hash algorithm and sorting strategy",
        "Documentation lists all three public functions with signatures and behavior",
        "Documentation describes the relationship to SASLSpec and TLSSpec",
        "Documentation is placed in docs/reference/backend/"
      ]
    }
  ],
  "requirements": [
    {
      "id": "REQ-001",
      "description": "computeSecretHash SHALL produce a deterministic SHA-256 hex string from the .data fields of all provided Secrets",
      "priority": "SHALL",
      "rationale": "The hash is the core mechanism for detecting Secret content changes; non-deterministic hashes would cause spurious rolling restarts",
      "scenarios": [
        {
          "name": "Same input produces same hash",
          "when": "computeSecretHash is called twice with the same Secret objects",
          "then": "both calls return the identical hex string",
          "and_then": []
        },
        {
          "name": "Different data produces different hash",
          "when": "computeSecretHash is called with a Secret whose .data value has changed",
          "then": "the returned hash differs from the previous call",
          "and_then": []
        },
        {
          "name": "Hash is hex-encoded SHA-256",
          "when": "computeSecretHash is called with any non-empty input",
          "then": "the returned string is exactly 64 lowercase hex characters",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-002",
      "description": "computeSecretHash SHALL produce the same hash regardless of the order of Secret arguments or the iteration order of keys within each Secret",
      "priority": "SHALL",
      "rationale": "Go map iteration is random; without explicit sorting, the hash would be non-deterministic and cause spurious restarts",
      "scenarios": [
        {
          "name": "Secret argument order independence",
          "when": "computeSecretHash is called with secrets [A, B] and then [B, A]",
          "then": "both calls return the identical hash",
          "and_then": []
        },
        {
          "name": "Key order independence within Secret",
          "when": "a Secret has keys {z: v1, a: v2} and Go iterates them in different orders",
          "then": "the hash is always the same because keys are sorted before hashing",
          "and_then": []
        },
        {
          "name": "Sorting strategy: Secret names first, then keys",
          "when": "multiple Secrets are provided",
          "then": "Secrets are sorted by .Name, then within each Secret, keys are sorted lexicographically",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-003",
      "description": "computeSecretHash SHALL return an empty string when called with zero Secrets or only Secrets with nil/empty .data",
      "priority": "SHALL",
      "rationale": "When no secrets are referenced (neither SASL nor TLS enabled), the hash must be a stable empty value to avoid unnecessary annotation changes",
      "scenarios": [
        {
          "name": "No secrets provided",
          "when": "computeSecretHash is called with no arguments",
          "then": "it returns an empty string",
          "and_then": []
        },
        {
          "name": "Secret with nil data",
          "when": "computeSecretHash is called with a Secret whose .data is nil",
          "then": "it returns an empty string (no data to hash)",
          "and_then": []
        },
        {
          "name": "Secret with empty data map",
          "when": "computeSecretHash is called with a Secret whose .data is map[string][]byte{}",
          "then": "it returns an empty string",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-004",
      "description": "fetchReferencedSecrets SHALL resolve SASLSpec.CredentialsSecretRef and TLSSpec.CertificateSecretRef from the Memcached CR and return found Secrets and missing Secret names",
      "priority": "SHALL",
      "rationale": "The reconciler needs the actual Secret objects for hashing and needs to know which Secrets are missing for status reporting",
      "scenarios": [
        {
          "name": "Both SASL and TLS Secrets exist",
          "when": "SASL and TLS are enabled and both referenced Secrets exist in the namespace",
          "then": "found list contains both Secrets, missing list is empty",
          "and_then": []
        },
        {
          "name": "SASL Secret missing",
          "when": "SASL is enabled but the referenced Secret does not exist",
          "then": "missing list contains the SASL Secret name, found list does not contain it",
          "and_then": []
        },
        {
          "name": "Neither SASL nor TLS enabled",
          "when": "Security spec is nil or both SASL and TLS are disabled",
          "then": "both found and missing lists are empty",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-005",
      "description": "fetchReferencedSecrets SHALL deduplicate when SASL and TLS reference the same Secret name",
      "priority": "SHALL",
      "rationale": "If the same Secret is referenced by both SASL and TLS, it should only appear once in the found list to avoid double-counting in the hash",
      "scenarios": [
        {
          "name": "Same Secret referenced by both",
          "when": "SASL credentialsSecretRef.name and TLS certificateSecretRef.name are identical",
          "then": "the found list contains the Secret exactly once",
          "and_then": []
        },
        {
          "name": "Same Secret name but Secret missing",
          "when": "SASL and TLS reference the same Secret name but it does not exist",
          "then": "the missing list contains the name exactly once",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-006",
      "description": "mapSecretToMemcached SHALL return a handler.MapFunc that maps Secret events to reconcile.Requests for Memcached CRs referencing that Secret",
      "priority": "SHALL",
      "rationale": "This is the core mechanism that triggers re-reconciliation when a referenced Secret changes",
      "scenarios": [
        {
          "name": "Secret referenced by one CR via SASL",
          "when": "a Secret changes and one Memcached CR has SASLSpec.CredentialsSecretRef.Name matching the Secret name",
          "then": "returns a single reconcile.Request for that CR",
          "and_then": []
        },
        {
          "name": "Secret referenced by multiple CRs",
          "when": "a Secret changes and two Memcached CRs reference it (one via SASL, one via TLS)",
          "then": "returns two reconcile.Requests, one for each CR",
          "and_then": []
        },
        {
          "name": "Secret not referenced by any CR",
          "when": "a Secret changes but no Memcached CR in the namespace references it",
          "then": "returns an empty list of reconcile.Requests",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-007",
      "description": "mapSecretToMemcached SHALL only consider Memcached CRs in the same namespace as the changed Secret",
      "priority": "SHALL",
      "rationale": "Secrets are namespace-scoped; cross-namespace references are not supported and would be a security concern",
      "scenarios": [
        {
          "name": "CR in same namespace matched",
          "when": "a Secret in namespace 'app' changes and a Memcached CR in namespace 'app' references it",
          "then": "the CR is included in the reconcile.Request list",
          "and_then": []
        },
        {
          "name": "CR in different namespace not matched",
          "when": "a Secret in namespace 'app' changes and a Memcached CR in namespace 'other' references a Secret with the same name",
          "then": "the CR in 'other' namespace is NOT included in the reconcile.Request list",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-008",
      "description": "mapSecretToMemcached SHALL handle Memcached CRs with nil Security, nil SASL, or nil TLS specs without panicking",
      "priority": "SHALL",
      "rationale": "Not all Memcached CRs enable SASL or TLS; nil pointer dereferences would crash the controller",
      "scenarios": [
        {
          "name": "CR with nil Security spec",
          "when": "a Memcached CR has spec.security = nil and a Secret event occurs",
          "then": "the CR is skipped without error or panic",
          "and_then": []
        },
        {
          "name": "CR with SASL nil but TLS set",
          "when": "a Memcached CR has spec.security.sasl = nil but spec.security.tls is set referencing the changed Secret",
          "then": "the CR is matched via TLS ref without panicking on SASL nil check",
          "and_then": []
        },
        {
          "name": "CR with TLS nil but SASL set",
          "when": "a Memcached CR has spec.security.tls = nil but spec.security.sasl is set referencing the changed Secret",
          "then": "the CR is matched via SASL ref without panicking on TLS nil check",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-009",
      "description": "All new code SHALL pass go vet and golangci-lint without errors",
      "priority": "SHALL",
      "rationale": "Project quality gate requires clean static analysis",
      "scenarios": [
        {
          "name": "go vet passes",
          "when": "go vet ./internal/controller/... is run",
          "then": "no errors are reported for secret.go",
          "and_then": []
        },
        {
          "name": "golangci-lint passes",
          "when": "golangci-lint run ./internal/controller/... is run",
          "then": "no errors are reported for secret.go or secret_test.go",
          "and_then": []
        }
      ]
    }
  ],
  "tasks": [
    {
      "id": "1.1",
      "title": "Implement computeSecretHash in internal/controller/secret.go (REQ-001, REQ-002, REQ-003)",
      "description": "Create `internal/controller/secret.go` with package `controller`. Implement `computeSecretHash(secrets ...*corev1.Secret) string` that: (1) returns empty string if no Secrets or all have nil/empty .data, (2) sorts Secrets by .Name, (3) for each Secret sorts .data keys, (4) writes `secretName\\0key\\0value` for each entry into a SHA-256 hasher, (5) returns hex-encoded digest. Import `crypto/sha256`, `encoding/hex`, `sort`, `k8s.io/api/core/v1`.",
      "level": 1,
      "estimate_minutes": 20,
      "status": "done",
      "requirements": [
        "REQ-001",
        "REQ-002",
        "REQ-003"
      ]
    },
    {
      "id": "1.2",
      "title": "Write unit tests for computeSecretHash in internal/controller/secret_test.go (REQ-001, REQ-002, REQ-003)",
      "description": "Create `internal/controller/secret_test.go` with package `controller`. Write table-driven tests: (1) same input same output (determinism), (2) secrets in reversed order produce same hash (order independence), (3) changed data produces different hash, (4) zero secrets returns empty string, (5) Secret with nil .data returns empty string, (6) Secret with empty .data map returns empty string, (7) hash is 64 hex chars, (8) two Secrets with keys sorted differently produce same hash. Follow the existing test pattern from `deployment_test.go` using standard `testing` package.",
      "level": 1,
      "estimate_minutes": 25,
      "status": "done",
      "requirements": [
        "REQ-001",
        "REQ-002",
        "REQ-003"
      ]
    },
    {
      "id": "1.3",
      "title": "Implement fetchReferencedSecrets in internal/controller/secret.go (REQ-004, REQ-005)",
      "description": "Add `fetchReferencedSecrets(ctx context.Context, c client.Client, mc *v1alpha1.Memcached) ([]*corev1.Secret, []string)` to secret.go. Collect unique Secret names from `mc.Spec.Security.SASL.CredentialsSecretRef.Name` (if SASL enabled) and `mc.Spec.Security.TLS.CertificateSecretRef.Name` (if TLS enabled). For each unique name, `c.Get()` the Secret in `mc.Namespace`. Append to found or missing list. Return (found, missing). Handle nil Security/SASL/TLS specs safely.",
      "level": 1,
      "estimate_minutes": 20,
      "status": "done",
      "requirements": [
        "REQ-004",
        "REQ-005"
      ]
    },
    {
      "id": "1.4",
      "title": "Write unit tests for fetchReferencedSecrets (REQ-004, REQ-005)",
      "description": "Add tests to `secret_test.go`: (1) both SASL+TLS Secrets exist -> both in found, none missing, (2) SASL Secret missing -> in missing list, (3) TLS Secret missing -> in missing list, (4) neither enabled -> both lists empty, (5) same Secret name for both refs -> appears once in found, (6) same Secret name missing -> appears once in missing, (7) nil Security spec -> empty lists. Use `fake.NewClientBuilder().WithScheme(testScheme()).WithObjects(...)` pattern from `reconcile_resource_test.go`.",
      "level": 1,
      "estimate_minutes": 25,
      "status": "done",
      "requirements": [
        "REQ-004",
        "REQ-005"
      ]
    },
    {
      "id": "2.1",
      "title": "Implement mapSecretToMemcached in internal/controller/secret.go (REQ-006, REQ-007, REQ-008)",
      "description": "Add `mapSecretToMemcached(ctx context.Context, c client.Client) handler.MapFunc` to secret.go. The returned `handler.MapFunc` receives a `client.Object` (the changed Secret). It lists all Memcached CRs in the Secret's namespace via `c.List()`. For each CR, check if `spec.security.sasl.credentialsSecretRef.name` or `spec.security.tls.certificateSecretRef.name` matches the Secret's name. Return `[]reconcile.Request` for matching CRs. Nil-check all nested spec fields. Import `sigs.k8s.io/controller-runtime/pkg/handler`, `sigs.k8s.io/controller-runtime/pkg/reconcile`.",
      "level": 2,
      "estimate_minutes": 20,
      "status": "done",
      "requirements": [
        "REQ-006",
        "REQ-007",
        "REQ-008"
      ]
    },
    {
      "id": "2.2",
      "title": "Write unit tests for mapSecretToMemcached (REQ-006, REQ-007, REQ-008)",
      "description": "Add tests to `secret_test.go`: (1) Secret referenced via SASL by one CR -> one Request returned, (2) Secret referenced via TLS by one CR -> one Request returned, (3) Secret referenced by two CRs (one SASL, one TLS) -> two Requests, (4) Secret not referenced -> empty list, (5) CR with nil Security spec -> skipped safely, (6) CR with SASL nil but TLS matching -> matched, (7) CR with TLS nil but SASL matching -> matched, (8) CRs in different namespace not matched. Use `fake.NewClientBuilder()` to create CRs and invoke the MapFunc directly.",
      "level": 2,
      "estimate_minutes": 25,
      "status": "done",
      "requirements": [
        "REQ-006",
        "REQ-007",
        "REQ-008"
      ]
    },
    {
      "id": "3.1",
      "title": "Write reference documentation for secret hash and map functions (REQ-001 through REQ-008)",
      "description": "Create `docs/reference/backend/secret-hash-computation.md`. Document: (1) Overview of the secret hash computation and reference resolution feature, (2) `computeSecretHash` signature, sorting algorithm, empty-input behavior, (3) `fetchReferencedSecrets` signature, which refs it resolves, deduplication, (4) `mapSecretToMemcached` signature, namespace scoping, nil-safety. Follow the structure and style of `docs/reference/backend/tls-encryption.md`.",
      "level": 3,
      "estimate_minutes": 15,
      "status": "done",
      "requirements": [
        "REQ-001",
        "REQ-002",
        "REQ-003",
        "REQ-004",
        "REQ-005",
        "REQ-006",
        "REQ-007",
        "REQ-008"
      ]
    }
  ],
  "test_specifications": [
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestComputeSecretHash_Determinism",
      "story": "Operator detects Secret data changes via deterministic hashing",
      "expected": "Calling computeSecretHash twice with the same Secret returns identical hex strings",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestComputeSecretHash_HexFormat",
      "story": "Operator detects Secret data changes via deterministic hashing",
      "expected": "The returned hash is exactly 64 lowercase hex characters",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestComputeSecretHash_OrderIndependence",
      "story": "Operator detects Secret data changes via deterministic hashing",
      "expected": "computeSecretHash([A, B]) == computeSecretHash([B, A])",
      "requirement_id": "REQ-002"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestComputeSecretHash_KeyOrderIndependence",
      "story": "Operator detects Secret data changes via deterministic hashing",
      "expected": "Secrets with keys in different insertion orders produce the same hash",
      "requirement_id": "REQ-002"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestComputeSecretHash_EmptyInput",
      "story": "Operator handles edge cases in Secret hash computation",
      "expected": "computeSecretHash() with no args returns empty string",
      "requirement_id": "REQ-003"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestComputeSecretHash_NilData",
      "story": "Operator handles edge cases in Secret hash computation",
      "expected": "computeSecretHash with Secret having nil .data returns empty string",
      "requirement_id": "REQ-003"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestComputeSecretHash_DataChange",
      "story": "Operator detects Secret data changes via deterministic hashing",
      "expected": "Changing a Secret's .data value produces a different hash",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestFetchReferencedSecrets_BothExist",
      "story": "Controller resolves referenced Secrets from Memcached CR spec",
      "expected": "When both SASL and TLS Secrets exist, found list contains both, missing list is empty",
      "requirement_id": "REQ-004"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestFetchReferencedSecrets_SASLMissing",
      "story": "Controller resolves referenced Secrets from Memcached CR spec",
      "expected": "When SASL Secret is missing, it appears in the missing list",
      "requirement_id": "REQ-004"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestFetchReferencedSecrets_NeitherEnabled",
      "story": "Controller resolves referenced Secrets from Memcached CR spec",
      "expected": "When neither SASL nor TLS is enabled, both lists are empty",
      "requirement_id": "REQ-004"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestFetchReferencedSecrets_Dedup",
      "story": "Operator handles edge cases in Secret reference resolution",
      "expected": "When SASL and TLS reference same Secret name, found list contains it once",
      "requirement_id": "REQ-005"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestMapSecretToMemcached_SASLRef",
      "story": "Secret changes trigger reconciliation of referencing Memcached CRs",
      "expected": "Returns reconcile.Request for CR whose SASL ref matches the Secret",
      "requirement_id": "REQ-006"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestMapSecretToMemcached_TLSRef",
      "story": "Secret changes trigger reconciliation of referencing Memcached CRs",
      "expected": "Returns reconcile.Request for CR whose TLS ref matches the Secret",
      "requirement_id": "REQ-006"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestMapSecretToMemcached_Unreferenced",
      "story": "Secret changes trigger reconciliation of referencing Memcached CRs",
      "expected": "Returns empty list when no CR references the Secret",
      "requirement_id": "REQ-006"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestMapSecretToMemcached_NamespaceScoping",
      "story": "Secret changes trigger reconciliation of referencing Memcached CRs",
      "expected": "CRs in a different namespace than the Secret are not matched",
      "requirement_id": "REQ-007"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestMapSecretToMemcached_NilSecuritySpec",
      "story": "Secret changes trigger reconciliation of referencing Memcached CRs",
      "expected": "CRs with nil Security spec are safely skipped without panic",
      "requirement_id": "REQ-008"
    },
    {
      "test_file": "internal/controller/secret_test.go",
      "test_function": "TestMapSecretToMemcached_MultipleCRs",
      "story": "Secret changes trigger reconciliation of referencing Memcached CRs",
      "expected": "Returns reconcile.Requests for all matching CRs when multiple CRs reference the same Secret",
      "requirement_id": "REQ-006"
    }
  ],
  "affected_files": [],
  "similar_patterns": [],
  "review_criteria": [
    "All unit tests pass: `go test ./internal/controller/... -run TestComputeSecretHash` and `TestFetchReferencedSecrets` and `TestMapSecretToMemcached` exit 0",
    "computeSecretHash is deterministic: calling it 100 times with the same input produces the same output (verified by test)",
    "computeSecretHash is order-independent: reversing Secret argument order and key insertion order produces identical hash (verified by test)",
    "fetchReferencedSecrets deduplicates when SASL and TLS reference the same Secret name (verified by test)",
    "mapSecretToMemcached nil-safety: CRs with nil Security/SASL/TLS specs do not cause panics (verified by test)",
    "mapSecretToMemcached namespace scoping: only CRs in the same namespace as the Secret are matched (verified by test)",
    "No new lint errors: `golangci-lint run ./internal/controller/...` passes with secret.go and secret_test.go",
    "go vet passes: `go vet ./internal/controller/...` reports no errors",
    "Code follows existing patterns: uses `package controller` for unit tests (matching deployment_test.go, status_test.go), uses `testScheme()` and `fake.NewClientBuilder()` from reconcile_resource_test.go",
    "Reference documentation in docs/reference/backend/secret-hash-computation.md follows the structure of docs/reference/backend/tls-encryption.md"
  ],
  "implementation_notes": "Architecture: All three functions are pure helpers in `internal/controller/secret.go` (package `controller`). They do not modify the MemcachedReconciler struct or the reconciliation loop â€” that integration is a separate feature (J002+). \n\n**computeSecretHash algorithm**: (1) Filter out Secrets with nil/empty .data. If none remain, return \"\". (2) Sort Secrets by .Name. (3) Create sha256.New() hasher. (4) For each Secret, sort .data keys, then write `secretName\\0key\\0value` using null byte separators to prevent ambiguity between key/value boundaries. (5) Return hex.EncodeToString(h.Sum(nil)).\n\n**fetchReferencedSecrets**: Collects unique Secret names into a map[string]struct{} from SASL and TLS refs (nil-checked). Iterates the map, does client.Get for each. Appends to found or missing slices.\n\n**mapSecretToMemcached**: Returns a closure over ctx and client. The closure receives the Secret object, lists all Memcached CRs in the Secret's namespace, filters by matching ref names, returns reconcile.Requests.\n\n**Test patterns**: Unit tests use `package controller` (same-package access) following deployment_test.go. Table-driven tests with `testing.T`. Fake client from `sigs.k8s.io/controller-runtime/pkg/client/fake` with `testScheme()` from reconcile_resource_test.go.\n\n**Key files to follow**: `internal/controller/deployment.go` (helper function pattern), `internal/controller/deployment_test.go` (table-driven test pattern), `internal/controller/reconcile_resource_test.go` (fake client setup with testScheme/newFakeClient), `api/v1alpha1/memcached_types.go` (SASLSpec, TLSSpec, SecuritySpec structs).\n\n**Risks**: (1) Go map iteration order is non-deterministic â€” mitigated by explicit key sorting. (2) The handler.MapFunc signature may vary between controller-runtime versions â€” the project uses v0.23.1, verify the exact signature. (3) Binary Secret data containing null bytes could theoretically create hash collisions â€” mitigated by using the Secret name as part of the hash input and accepting this minimal theoretical risk.",
  "status_history": {
    "proposed": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T15:48:10.848908"
    },
    "preparing": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T16:38:20.842740"
    },
    "prepared": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T16:41:24.128101"
    },
    "processing": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T16:50:05.522262"
    },
    "approved": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T17:11:50.590192"
    },
    "completed": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T17:11:50.611506"
    }
  },
  "execution_history": [
    {
      "run_id": "7de44c72-5684-4ac4-8acd-1b1652131005",
      "timestamp": "2026-02-21T16:41:24.128129",
      "total_duration": 180.2677993774414,
      "status": "completed",
      "timings": [
        {
          "name": "prepare",
          "duration": 180.2677993774414,
          "type": "prepare",
          "status": "done"
        }
      ]
    },
    {
      "run_id": "204fc6e3-3e13-496f-9d75-f225aeb4a9cb",
      "timestamp": "2026-02-21T17:08:32.261154",
      "total_duration": 1018.4344108104706,
      "status": "completed",
      "timings": [
        {
          "name": "Level 1 (4 tasks)",
          "duration": 488.0133762359619,
          "type": "level",
          "status": "done"
        },
        {
          "name": "Level 2 (2 tasks)",
          "duration": 40.39981508255005,
          "type": "level",
          "status": "done"
        },
        {
          "name": "Level 3 (1 tasks)",
          "duration": 91.79993057250977,
          "type": "level",
          "status": "done"
        },
        {
          "name": "[MO-0037] Code Review",
          "duration": 221.9453046321869,
          "type": "review",
          "status": "done"
        },
        {
          "name": "[MO-0037] Improvements",
          "duration": 78.899827003479,
          "type": "improve",
          "status": "done"
        },
        {
          "name": "[MO-0037] Simplify",
          "duration": 97.37615728378296,
          "type": "simplify",
          "status": "done"
        }
      ]
    }
  ]
}