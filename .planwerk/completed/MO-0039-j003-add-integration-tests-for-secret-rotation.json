{
  "feature_id": "MO-0039",
  "title": "J003: Add integration tests for Secret rotation flows",
  "slug": "j003-add-integration-tests-for-secret-rotation",
  "status": "completed",
  "phase": "awaiting_external_review",
  "summary": "",
  "description": "**Size:** ðŸ“¦ medium\n**Category:** testing\n**Priority:** high\n**Source:** Proposed for 'Secret Rotation & Rolling Restart\n\n  Automatic'\n\nCreate integration tests using the existing envtest setup to validate the complete Secret rotation and restart flow end-to-end:\n\n**Secret rotation rolling restart test:**\n1. Create a Memcached CR with SASL and/or TLS Secret references\n2. Create the referenced Secrets with initial data\n3. Verify Deployment is created with `memcached.c5c3.io/secret-hash` annotation containing the correct hash\n4. Update the Secret's `.data` field\n5. Verify the controller re-reconciles and updates the Deployment's Pod template annotation with the new hash\n6. Verify the Deployment's Pod template generation changes (indicating a rolling update would be triggered)\n\n**Missing Secret Degraded condition test:**\n1. Create a Memcached CR referencing a Secret that does not exist\n2. Verify the Memcached CR status has `Degraded=True` with reason `SecretNotFound` and the missing Secret name in the message\n3. Create the missing Secret\n4. Verify the Degraded condition is removed on next reconciliation\n\n**Manual restart trigger test:**\n1. Create a Memcached CR with Secrets, note the initial Pod template generation\n2. Add/update annotation `memcached.c5c3.io/restart-trigger` on the CR (e.g., set to a timestamp)\n3. Verify the Deployment's Pod template annotation is updated with the trigger value\n4. Verify the Pod template generation changes\n\n**Secret watch filtering test:**\n1. Create two Memcached CRs â€” one referencing SecretA, one referencing SecretB\n2. Update SecretA\n3. Verify only the first CR is re-reconciled (not the second)\n\n**Rationale:** Unit tests alone cannot verify the complete reconciliation loop including Secret watches, status updates, and Deployment mutations working together. Integration tests with envtest validate that the Secret watcher correctly triggers reconciliation, the hash is recomputed, and the Deployment is updated â€” the actual user-facing behavior. Without these tests, regressions in the watch-to-reconcile-to-deploy chain would go undetected.\n\n**Affected Areas:**\n- internal/controller/memcached_controller_test.go\n- internal/controller/suite_test.go",
  "stories": [
    {
      "title": "Operator detects Secret data changes and triggers rolling restart",
      "role": "operator/cluster administrator",
      "want": "the Memcached Deployment to automatically roll when a referenced SASL or TLS Secret's data changes",
      "so_that": "Memcached pods pick up rotated credentials/certificates without manual intervention",
      "criteria": [
        "When a Memcached CR references a SASL Secret and the Secret exists, the Deployment's pod template annotation `memcached.c5c3.io/secret-hash` contains a non-empty SHA-256 hex hash",
        "When the Secret's `.data` field is updated, reconciliation produces a different hash value in the pod template annotation",
        "The Deployment's pod template ResourceVersion changes after the hash update, confirming a rolling update would be triggered",
        "The hash is deterministic: same Secret data always produces the same hash regardless of reconcile order"
      ]
    },
    {
      "title": "Operator reports Degraded status when referenced Secret is missing",
      "role": "operator/cluster administrator",
      "want": "the Memcached CR to report a clear Degraded condition when a referenced Secret does not exist",
      "so_that": "I can quickly identify and fix missing Secret issues before they cause service disruption",
      "criteria": [
        "When a Memcached CR references a non-existent Secret, status condition `Degraded=True` is set with reason `SecretNotFound`",
        "The Degraded condition message includes the name of the missing Secret",
        "When the missing Secret is created, the Degraded condition is removed (reason changes to `NotDegraded` or `Degraded` based on replica status) on next reconciliation",
        "SecretNotFound Degraded takes precedence over replica-based Degraded"
      ]
    },
    {
      "title": "Operator supports manual restart trigger via annotation",
      "role": "operator/cluster administrator",
      "want": "to trigger a rolling restart of Memcached pods by setting an annotation on the CR",
      "so_that": "I can force a restart without changing the spec (e.g., to clear caches or apply external config changes)",
      "criteria": [
        "When annotation `memcached.c5c3.io/restart-trigger` is set on the Memcached CR, the value is propagated to the Deployment's pod template annotation",
        "The Deployment's pod template ResourceVersion changes after the annotation is set",
        "Updating the restart-trigger annotation value produces a new pod template annotation value",
        "The restart-trigger annotation coexists with the secret-hash annotation without interference"
      ]
    },
    {
      "title": "Secret watch filters reconciliation to only affected CRs",
      "role": "operator/cluster administrator",
      "want": "Secret changes to trigger reconciliation only for Memcached CRs that reference the changed Secret",
      "so_that": "unrelated Memcached instances are not unnecessarily reconciled, reducing control loop overhead",
      "criteria": [
        "When SecretA is updated, only the Memcached CR referencing SecretA is re-reconciled",
        "A second Memcached CR referencing SecretB is not affected when SecretA changes",
        "The mapSecretToMemcached function correctly filters by Secret name and namespace"
      ]
    },
    {
      "title": "Integration tests validate end-to-end Secret rotation flow",
      "role": "developer",
      "want": "integration tests using envtest that validate the complete Secret rotation and restart flow end-to-end",
      "so_that": "regressions in the watch-to-reconcile-to-deploy chain are detected automatically in CI",
      "criteria": [
        "All four test scenarios (Secret rotation, missing Secret, manual restart, Secret watch filtering) pass in envtest",
        "Tests follow existing Ginkgo/Gomega patterns with uniqueName() for isolation",
        "Tests use reconcileOnce() helper for explicit reconciliation control",
        "Tests verify actual Kubernetes object state via k8sClient.Get()"
      ]
    }
  ],
  "requirements": [
    {
      "id": "REQ-001",
      "description": "The controller SHALL update the Deployment pod template annotation `memcached.c5c3.io/secret-hash` with a new hash when a referenced Secret's `.data` field changes",
      "priority": "SHALL",
      "rationale": "Ensures Memcached pods are automatically restarted with updated credentials/certificates after Secret rotation",
      "scenarios": [
        {
          "name": "Initial Secret creates hash annotation",
          "when": "a Memcached CR with SASL enabled references an existing Secret and is reconciled",
          "then": "the Deployment's pod template has annotation `memcached.c5c3.io/secret-hash` set to a non-empty 64-char hex string",
          "and_then": [
            "the hash matches computeSecretHash() for that Secret's data"
          ]
        },
        {
          "name": "Secret data update changes hash",
          "when": "the Secret's `.data` field is modified and reconciliation runs",
          "then": "the Deployment's pod template annotation `memcached.c5c3.io/secret-hash` contains a different hash value than before",
          "and_then": [
            "the Deployment's pod template ResourceVersion changes, indicating a rolling update would be triggered"
          ]
        },
        {
          "name": "No Secret references results in no hash annotation",
          "when": "a Memcached CR has no SASL or TLS Secret references and is reconciled",
          "then": "the Deployment's pod template has no `memcached.c5c3.io/secret-hash` annotation",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-002",
      "description": "The controller SHALL set the Degraded condition to True with reason SecretNotFound when a referenced Secret does not exist",
      "priority": "SHALL",
      "rationale": "Provides immediate visibility into configuration issues that prevent proper Secret mounting",
      "scenarios": [
        {
          "name": "Missing Secret sets Degraded=True",
          "when": "a Memcached CR references a non-existent Secret and is reconciled",
          "then": "the Memcached CR status has condition Degraded=True with reason=SecretNotFound",
          "and_then": [
            "the condition message includes the missing Secret name"
          ]
        },
        {
          "name": "Creating missing Secret clears Degraded",
          "when": "the previously missing Secret is created and reconciliation runs",
          "then": "the Degraded condition is no longer SecretNotFound",
          "and_then": [
            "the Degraded condition reason reflects the current replica-based status (Degraded or NotDegraded)"
          ]
        },
        {
          "name": "SecretNotFound takes precedence over replica-based Degraded",
          "when": "a Memcached CR has missing Secrets AND insufficient ready replicas",
          "then": "the Degraded condition reason is SecretNotFound (not Degraded)",
          "and_then": [
            "the message mentions the missing Secret names"
          ]
        }
      ]
    },
    {
      "id": "REQ-003",
      "description": "The controller SHALL propagate the CR annotation `memcached.c5c3.io/restart-trigger` to the Deployment pod template annotation",
      "priority": "SHALL",
      "rationale": "Enables operators to trigger rolling restarts without spec changes for operational flexibility",
      "scenarios": [
        {
          "name": "Restart trigger annotation is propagated",
          "when": "a Memcached CR has annotation `memcached.c5c3.io/restart-trigger` set and is reconciled",
          "then": "the Deployment's pod template has annotation `memcached.c5c3.io/restart-trigger` with the same value",
          "and_then": [
            "the Deployment's pod template ResourceVersion changes"
          ]
        },
        {
          "name": "Updating restart trigger changes pod template",
          "when": "the restart-trigger annotation value is changed on the CR and reconciliation runs",
          "then": "the Deployment's pod template annotation value is updated to match",
          "and_then": [
            "the Deployment's pod template ResourceVersion changes again"
          ]
        },
        {
          "name": "No restart trigger results in no annotation",
          "when": "a Memcached CR has no restart-trigger annotation",
          "then": "the Deployment's pod template has no `memcached.c5c3.io/restart-trigger` annotation",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-004",
      "description": "The Secret watch SHALL only trigger reconciliation for Memcached CRs that reference the changed Secret via SASL or TLS spec",
      "priority": "SHALL",
      "rationale": "Prevents unnecessary reconciliation of unrelated Memcached instances, reducing API server load",
      "scenarios": [
        {
          "name": "Only referencing CR is reconciled",
          "when": "two Memcached CRs exist â€” CR-A references SecretA, CR-B references SecretB â€” and SecretA is updated",
          "then": "only CR-A's Deployment annotation is updated",
          "and_then": [
            "CR-B's Deployment remains unchanged (same ResourceVersion)"
          ]
        },
        {
          "name": "Unreferenced Secret triggers no reconciliation",
          "when": "a Secret is updated that is not referenced by any Memcached CR",
          "then": "no Memcached CRs are re-reconciled",
          "and_then": []
        },
        {
          "name": "Multiple CRs referencing same Secret are all reconciled",
          "when": "two Memcached CRs reference the same Secret and it is updated",
          "then": "both CRs are re-reconciled and their Deployment annotations are updated",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-005",
      "description": "The integration tests SHALL use the existing envtest framework and follow established test patterns (uniqueName, validMemcached, reconcileOnce, fetchDeployment)",
      "priority": "SHALL",
      "rationale": "Consistency with existing test patterns ensures maintainability and reduces cognitive load for contributors",
      "scenarios": [
        {
          "name": "Tests use unique names for isolation",
          "when": "any test creates a Memcached CR",
          "then": "the CR name is generated via uniqueName() to prevent cross-test interference",
          "and_then": []
        },
        {
          "name": "Tests use reconcileOnce for explicit control",
          "when": "a test needs to trigger reconciliation",
          "then": "it calls reconcileOnce(mc) rather than relying on the controller manager watch loop",
          "and_then": [
            "the test explicitly verifies the reconcile result and error"
          ]
        },
        {
          "name": "Tests verify state via k8sClient",
          "when": "a test needs to verify Kubernetes object state",
          "then": "it uses k8sClient.Get() or fetchDeployment()/fetchService() helpers",
          "and_then": [
            "assertions use Gomega matchers (Expect, To, Equal, etc.)"
          ]
        }
      ]
    },
    {
      "id": "REQ-006",
      "description": "The Secret rotation test SHALL verify that the Deployment pod template generation changes when the Secret hash changes",
      "priority": "SHALL",
      "rationale": "The pod template generation change is what actually triggers Kubernetes to perform a rolling update â€” verifying only the annotation is insufficient",
      "scenarios": [
        {
          "name": "Pod template ResourceVersion changes on hash update",
          "when": "a Secret's data is updated and reconciliation runs",
          "then": "the Deployment object's ResourceVersion is different from before the update",
          "and_then": [
            "this confirms the Deployment was mutated, which Kubernetes would interpret as a rollout trigger"
          ]
        },
        {
          "name": "Pod template ResourceVersion stable when no change",
          "when": "reconciliation runs without any Secret or spec changes",
          "then": "the Deployment object's ResourceVersion remains the same (idempotent)",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-007",
      "description": "The tests SHALL create actual Secret objects in envtest and verify the complete reconciliation loop including Secret fetch, hash computation, and Deployment mutation",
      "priority": "SHALL",
      "rationale": "Integration tests must exercise the real reconciliation path, not mocked components, to catch watch-to-reconcile-to-deploy chain regressions",
      "scenarios": [
        {
          "name": "Real Secrets are created and fetched",
          "when": "a test creates a Secret via k8sClient.Create()",
          "then": "the reconciler fetches it via fetchReferencedSecrets() and computes the hash",
          "and_then": [
            "the Deployment annotation contains the correct hash for the Secret data"
          ]
        },
        {
          "name": "Real Secrets are updated and re-fetched",
          "when": "a test updates a Secret's data via k8sClient.Update()",
          "then": "the next reconciliation fetches the updated data and recomputes the hash",
          "and_then": [
            "the Deployment annotation contains the new hash"
          ]
        }
      ]
    },
    {
      "id": "REQ-008",
      "description": "The integration tests SHALL be placed in internal/controller/memcached_secret_rotation_integration_test.go following the project file naming convention",
      "priority": "SHALL",
      "rationale": "Following the existing file naming pattern (memcached_*_test.go) ensures discoverability and consistency",
      "scenarios": [
        {
          "name": "Test file follows naming convention",
          "when": "the test file is created",
          "then": "it is named memcached_secret_rotation_integration_test.go in the internal/controller/ directory",
          "and_then": [
            "it uses package controller_test and imports the same packages as existing integration tests"
          ]
        },
        {
          "name": "Tests compile and pass",
          "when": "go test ./internal/controller/... is run",
          "then": "all new tests compile without errors and pass",
          "and_then": [
            "no existing tests are broken by the additions"
          ]
        }
      ]
    }
  ],
  "tasks": [
    {
      "id": "1.1",
      "title": "Write Secret rotation rolling restart integration tests with SASL Secret (REQ-001, REQ-005, REQ-006, REQ-007)",
      "description": "Create file `internal/controller/memcached_secret_rotation_integration_test.go` in package `controller_test`. Write a Ginkgo `Describe('Secret rotation rolling restart')` block with these `It` tests:\n\n1. **should create Deployment with secret-hash annotation when SASL Secret exists**: Create a `corev1.Secret` named `uniqueName('sasl-secret')` in namespace `default` with `.data['password-file']='initial-password'`. Create a Memcached CR via `validMemcached()` with `spec.security.sasl.enabled=true, credentialsSecretRef.name=<secret-name>`. Call `reconcileOnce()`. Fetch Deployment and assert `dep.Spec.Template.Annotations['memcached.c5c3.io/secret-hash']` is a non-empty 64-char hex string.\n\n2. **should update secret-hash and change Deployment ResourceVersion when Secret data changes**: Continue from test 1 setup. Record initial Deployment ResourceVersion and hash. Re-fetch Secret, update `.data['password-file']='rotated-password'`, call `k8sClient.Update()`. Call `reconcileOnce()`. Assert the new hash differs from the initial hash and the Deployment ResourceVersion changed.\n\n3. **should create Deployment with secret-hash annotation when TLS Secret exists**: Same pattern but with `spec.security.tls.enabled=true, certificateSecretRef.name=<secret-name>` and a Secret with `tls.crt` and `tls.key` data keys.\n\n4. **should handle both SASL and TLS Secrets together**: Create both SASL and TLS Secrets with different names. Configure CR with both enabled. Verify hash covers both Secrets. Update only the SASL Secret data, verify hash changes.\n\nFollow existing patterns: `uniqueName()` for all names, `validMemcached()` as base CR, `reconcileOnce()` for reconciliation, `fetchDeployment()` for assertions. Import `controller` package for `AnnotationSecretHash` constant.",
      "level": 1,
      "estimate_minutes": 25,
      "status": "done",
      "requirements": [
        "REQ-001",
        "REQ-005",
        "REQ-006",
        "REQ-007"
      ]
    },
    {
      "id": "1.2",
      "title": "Write Missing Secret Degraded condition integration tests (REQ-002, REQ-005, REQ-007)",
      "description": "In the same file `internal/controller/memcached_secret_rotation_integration_test.go`, add a Ginkgo `Describe('Missing Secret Degraded condition')` block with these `It` tests:\n\n1. **should set Degraded=True with SecretNotFound when Secret does not exist**: Create a Memcached CR with `spec.security.sasl.enabled=true, credentialsSecretRef.name='nonexistent-secret-<unique>'`. Do NOT create the Secret. Call `reconcileOnce()`. Re-fetch the Memcached CR. Use `findCondition()` helper to get the `Degraded` condition. Assert `Status=True`, `Reason='SecretNotFound'`, and `Message` contains the missing Secret name.\n\n2. **should clear Degraded SecretNotFound when missing Secret is created**: Continue from scenario 1. Now create the Secret via `k8sClient.Create()`. Call `reconcileOnce()` again. Re-fetch the Memcached CR. Assert Degraded condition reason is no longer `SecretNotFound` (it should be `Degraded` because envtest has 0 ready replicas, or `NotDegraded` if 0 replicas desired).\n\n3. **should set Degraded=True with multiple missing Secret names in message**: Create a Memcached CR with both SASL and TLS enabled, both referencing non-existent Secrets with different names. Call `reconcileOnce()`. Assert Degraded=True with SecretNotFound and message containing both Secret names.\n\nUse `findCondition()` from `memcached_status_reconcile_test.go` and the same Ginkgo/Gomega assertion patterns.",
      "level": 1,
      "estimate_minutes": 20,
      "status": "done",
      "requirements": [
        "REQ-002",
        "REQ-005",
        "REQ-007"
      ]
    },
    {
      "id": "1.3",
      "title": "Write manual restart trigger integration tests (REQ-003, REQ-005, REQ-006)",
      "description": "In the same file, add a Ginkgo `Describe('Manual restart trigger')` block with these `It` tests:\n\n1. **should propagate restart-trigger annotation to Deployment pod template**: Create a Memcached CR with SASL Secret (so we can also test coexistence). Create the Secret. Call `reconcileOnce()`. Record initial Deployment ResourceVersion. Re-fetch the Memcached CR, set `mc.Annotations['memcached.c5c3.io/restart-trigger'] = '2024-01-15T10:00:00Z'`, call `k8sClient.Update()`. Call `reconcileOnce()`. Fetch Deployment and assert `dep.Spec.Template.Annotations['memcached.c5c3.io/restart-trigger'] == '2024-01-15T10:00:00Z'`. Assert Deployment ResourceVersion changed.\n\n2. **should update Deployment when restart-trigger annotation value changes**: Continue from test 1. Update the CR annotation to a new timestamp value. Call `reconcileOnce()`. Assert the new pod template annotation value matches. Assert Deployment ResourceVersion changed again.\n\n3. **should coexist with secret-hash annotation**: After tests 1-2, verify the Deployment pod template has BOTH `memcached.c5c3.io/secret-hash` (non-empty) and `memcached.c5c3.io/restart-trigger` annotations simultaneously.\n\n4. **should propagate restart-trigger on CR without Secrets**: Create a minimal Memcached CR (no SASL/TLS). Set restart-trigger annotation. Reconcile. Assert the Deployment pod template has only the restart-trigger annotation (no secret-hash since no Secrets).\n\nUse `controller.AnnotationRestartTrigger` and `controller.AnnotationSecretHash` constants.",
      "level": 1,
      "estimate_minutes": 20,
      "status": "done",
      "requirements": [
        "REQ-003",
        "REQ-005",
        "REQ-006"
      ]
    },
    {
      "id": "1.4",
      "title": "Write Secret watch filtering integration tests (REQ-004, REQ-005)",
      "description": "In the same file, add a Ginkgo `Describe('Secret watch filtering')` block with these `It` tests:\n\n1. **should only reconcile the CR referencing the updated Secret**: Create SecretA and SecretB with unique names. Create CR-A with SASL referencing SecretA and CR-B with SASL referencing SecretB. Call `reconcileOnce()` for both CRs. Record both Deployments' ResourceVersions and hash annotations. Update SecretA's data. Call `reconcileOnce()` for CR-A only. Assert CR-A's Deployment ResourceVersion changed and hash annotation changed. Fetch CR-B's Deployment and assert its ResourceVersion is unchanged.\n\n2. **should not affect CRs referencing different Secrets when one Secret is updated**: Same setup as test 1 but also reconcile CR-B after SecretA update. Assert CR-B's Deployment ResourceVersion and hash annotation remain the same (since SecretB was not modified).\n\nNote: In envtest with `reconcileOnce()` we control which CR is reconciled explicitly. The filtering behavior is tested by verifying that reconciling CR-B after SecretA changes does NOT change CR-B's Deployment (because CR-B reads SecretB which was not modified). The mapSecretToMemcached function is already unit-tested; here we verify the end-to-end behavior.",
      "level": 1,
      "estimate_minutes": 20,
      "status": "done",
      "requirements": [
        "REQ-004",
        "REQ-005"
      ]
    },
    {
      "id": "3.1",
      "title": "Write Reference documentation for Secret rotation integration tests (REQ-008)",
      "description": "Update the existing `docs/reference/backend/envtest-integration-tests.md` to add a new section covering the Secret rotation integration tests. Document: (1) the four test scenarios covered (Secret rotation, missing Secret, manual restart, Secret watch filtering), (2) the test file location, (3) how to run the tests, (4) what each test verifies in terms of the reconciliation loop. Follow the existing documentation format and structure in the file.",
      "level": 3,
      "estimate_minutes": 15,
      "status": "done",
      "requirements": [
        "REQ-008"
      ]
    }
  ],
  "test_specifications": [
    {
      "test_file": "internal/controller/memcached_secret_rotation_integration_test.go",
      "test_function": "Secret rotation rolling restart / should create Deployment with secret-hash annotation when SASL Secret exists",
      "story": "Operator detects Secret data changes and triggers rolling restart",
      "expected": "Deployment pod template should have memcached.c5c3.io/secret-hash annotation with non-empty 64-char hex string matching computeSecretHash for the created Secret",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "internal/controller/memcached_secret_rotation_integration_test.go",
      "test_function": "Secret rotation rolling restart / should update secret-hash and change Deployment ResourceVersion when Secret data changes",
      "story": "Operator detects Secret data changes and triggers rolling restart",
      "expected": "After Secret data update and reconciliation, the Deployment annotation has a different hash and the Deployment ResourceVersion changes",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "internal/controller/memcached_secret_rotation_integration_test.go",
      "test_function": "Secret rotation rolling restart / should create Deployment with secret-hash annotation when TLS Secret exists",
      "story": "Operator detects Secret data changes and triggers rolling restart",
      "expected": "Deployment pod template should have memcached.c5c3.io/secret-hash annotation when TLS Secret reference is configured",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "internal/controller/memcached_secret_rotation_integration_test.go",
      "test_function": "Missing Secret Degraded condition / should set Degraded=True with SecretNotFound when Secret does not exist",
      "story": "Operator reports Degraded status when referenced Secret is missing",
      "expected": "Memcached CR status should have Degraded=True condition with reason SecretNotFound and message containing the missing Secret name",
      "requirement_id": "REQ-002"
    },
    {
      "test_file": "internal/controller/memcached_secret_rotation_integration_test.go",
      "test_function": "Missing Secret Degraded condition / should clear Degraded SecretNotFound when missing Secret is created",
      "story": "Operator reports Degraded status when referenced Secret is missing",
      "expected": "After creating the missing Secret and reconciling, Degraded condition reason should no longer be SecretNotFound",
      "requirement_id": "REQ-002"
    },
    {
      "test_file": "internal/controller/memcached_secret_rotation_integration_test.go",
      "test_function": "Manual restart trigger / should propagate restart-trigger annotation to Deployment pod template",
      "story": "Operator supports manual restart trigger via annotation",
      "expected": "Deployment pod template should have memcached.c5c3.io/restart-trigger annotation matching the CR annotation value, and Deployment ResourceVersion should change",
      "requirement_id": "REQ-003"
    },
    {
      "test_file": "internal/controller/memcached_secret_rotation_integration_test.go",
      "test_function": "Manual restart trigger / should update Deployment when restart-trigger annotation value changes",
      "story": "Operator supports manual restart trigger via annotation",
      "expected": "After updating the restart-trigger annotation and reconciling, the Deployment pod template annotation should have the new value",
      "requirement_id": "REQ-003"
    },
    {
      "test_file": "internal/controller/memcached_secret_rotation_integration_test.go",
      "test_function": "Secret watch filtering / should only reconcile the CR referencing the updated Secret",
      "story": "Secret watch filters reconciliation to only affected CRs",
      "expected": "When SecretA is updated and both CRs are reconciled, only CR-A's Deployment annotation changes; CR-B's Deployment ResourceVersion remains the same",
      "requirement_id": "REQ-004"
    },
    {
      "test_file": "internal/controller/memcached_secret_rotation_integration_test.go",
      "test_function": "Secret rotation rolling restart / should handle both SASL and TLS Secrets together",
      "story": "Operator detects Secret data changes and triggers rolling restart",
      "expected": "When both SASL and TLS Secrets are configured and exist, the hash covers both; updating either Secret changes the hash",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "internal/controller/memcached_secret_rotation_integration_test.go",
      "test_function": "Manual restart trigger / should coexist with secret-hash annotation",
      "story": "Operator supports manual restart trigger via annotation",
      "expected": "Deployment pod template should have both memcached.c5c3.io/secret-hash and memcached.c5c3.io/restart-trigger annotations simultaneously",
      "requirement_id": "REQ-003"
    },
    {
      "test_file": "internal/controller/memcached_secret_rotation_integration_test.go",
      "test_function": "Missing Secret Degraded condition / should set Degraded=True with multiple missing Secret names in message",
      "story": "Operator reports Degraded status when referenced Secret is missing",
      "expected": "When both SASL and TLS Secrets are missing, Degraded condition message includes both Secret names",
      "requirement_id": "REQ-002"
    }
  ],
  "affected_files": [],
  "similar_patterns": [],
  "review_criteria": [
    "All four test scenarios (Secret rotation, missing Secret Degraded, manual restart trigger, Secret watch filtering) have corresponding passing Ginkgo tests",
    "All WHEN/THEN scenarios from REQ-001 through REQ-004 are covered by at least one test case",
    "Tests follow existing patterns: uniqueName() for CR names, validMemcached() as base, reconcileOnce() for reconciliation, fetchDeployment() for assertions",
    "Tests create actual Secret objects in envtest and verify the complete reconciliation loop (no mocking of fetchReferencedSecrets or computeSecretHash)",
    "go vet and golangci-lint pass without errors on the new test file",
    "No existing tests are broken by the additions (full test suite passes)",
    "Test file is named memcached_secret_rotation_integration_test.go in internal/controller/ and uses package controller_test",
    "Tests verify both annotation values AND Deployment ResourceVersion changes to confirm rolling update trigger"
  ],
  "implementation_notes": "All tests go in a single new file: internal/controller/memcached_secret_rotation_integration_test.go. This follows the project pattern of grouping related integration tests by feature (e.g., memcached_envtest_integration_test.go, memcached_tls_deployment_reconcile_test.go). Tests use the existing envtest infrastructure from suite_test.go (k8sClient, ctx, scheme). The reconcileOnce() helper creates a fresh MemcachedReconciler per call â€” it does NOT use the controller manager's watch loop, so Secret watch filtering is tested by verifying that reconciling a CR produces the correct Deployment state based on which Secrets exist and are referenced. The mapSecretToMemcached function has separate unit tests in secret_test.go. Secrets must be created BEFORE the Memcached CR in tests that expect the Secret to exist, since reconcileOnce() fetches Secrets synchronously. For the 'missing Secret' tests, the Secret is intentionally not created. Use the controller package's exported constants (AnnotationSecretHash, AnnotationRestartTrigger) for annotation key assertions. The findCondition() helper is defined in memcached_status_reconcile_test.go and is available across the package. When updating CR annotations, always re-fetch the CR first to get the latest resourceVersion.",
  "status_history": {
    "proposed": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T15:48:10.850127"
    },
    "preparing": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T20:47:27.772627"
    },
    "prepared": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T20:52:47.211110"
    },
    "processing": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T20:52:52.331942"
    },
    "completed": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T21:14:40.596198"
    }
  },
  "execution_history": [
    {
      "run_id": "820cff3d-82b1-49a0-8c04-f0902eba5ad7",
      "timestamp": "2026-02-21T20:52:47.211137",
      "total_duration": 316.0538833141327,
      "status": "completed",
      "timings": [
        {
          "name": "prepare",
          "duration": 316.0538833141327,
          "type": "prepare",
          "status": "done"
        }
      ]
    },
    {
      "run_id": "f402081c-51ad-4f71-a29a-7b38a126731e",
      "timestamp": "2026-02-21T21:14:14.515604",
      "total_duration": 1159.1901233196259,
      "status": "completed",
      "timings": [
        {
          "name": "Level 1 (4 tasks)",
          "duration": 501.5916407108307,
          "type": "level",
          "status": "done"
        },
        {
          "name": "Level 3 (1 tasks)",
          "duration": 106.13443803787231,
          "type": "level",
          "status": "done"
        },
        {
          "name": "[MO-0039] Code Review",
          "duration": 131.21781492233276,
          "type": "review",
          "status": "done"
        },
        {
          "name": "[MO-0039] Improvements",
          "duration": 69.69604802131653,
          "type": "improve",
          "status": "done"
        },
        {
          "name": "[MO-0039] Simplify",
          "duration": 350.55018162727356,
          "type": "simplify",
          "status": "done"
        }
      ]
    }
  ]
}