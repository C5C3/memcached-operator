{
  "feature_id": "MO-0038",
  "title": "J002: Deployment annotation propagation and Degraded status condition",
  "slug": "j002-deployment-annotation-propagation-and",
  "status": "proposed",
  "phase": null,
  "summary": "",
  "description": "**Size:** ðŸ“¦ medium\n**Category:** backend\n**Priority:** critical\n**Source:** Proposed for 'Secret Rotation & Rolling Restart\n\n  Automatic'\n\nWire the secret hash and restart trigger into the Deployment and status conditions:\n\n**Deployment changes (`internal/controller/deployment.go`):**\n- Extend `constructDeployment` to accept `secretHash string` and `restartTrigger string` parameters\n- Set `dep.Spec.Template.ObjectMeta.Annotations[\"memcached.c5c3.io/secret-hash\"]` with the computed hash\n- Set `dep.Spec.Template.ObjectMeta.Annotations[\"memcached.c5c3.io/restart-trigger\"]` with the trigger value from the CR\n- When either annotation value changes, Kubernetes automatically triggers a rolling update\n\n**Status changes (`internal/controller/status.go`):**\n- Add constant `ConditionReasonSecretNotFound = \"SecretNotFound\"`\n- Extend `computeConditions` to accept `missingSecrets []string` parameter\n- When `missingSecrets` is non-empty, set `Degraded=True` with reason `SecretNotFound` and message listing the missing Secret names\n\n**Controller wiring (`internal/controller/memcached_controller.go`):**\n- In `reconcileDeployment`: call `fetchReferencedSecrets` to get Secrets + missing names, call `computeSecretHash` on found Secrets\n- Read `memcached.c5c3.io/restart-trigger` from `mc.Annotations`\n- Pass `secretHash` and `restartTrigger` to `constructDeployment`\n- Pass `missingSecrets` to condition/status logic\n- In `SetupWithManager`: add `.Watches(&corev1.Secret{}, handler.EnqueueRequestsFromMapFunc(mapSecretToMemcached(ctx, mgr.GetClient())))` to watch Secret changes\n\n**Test updates:**\n- `internal/controller/deployment_test.go`: Add cases verifying `secret-hash` and `restart-trigger` annotations appear on Pod template; verify annotations are empty/absent when no Secrets referenced\n- `internal/controller/status_test.go`: Add cases for `SecretNotFound` Degraded condition when Secrets are missing; verify no Degraded condition when all Secrets are found\n\n**Rationale:** This is the integration layer connecting the hash computation to the actual rolling restart mechanism. Without it, even with correct hash computation, Secret changes would not trigger Pod restarts. The Degraded condition provides critical operational visibility â€” operators need to know immediately when a referenced Secret is missing, rather than debugging failed Pod mounts after the fact.\n\n**Affected Areas:**\n- internal/controller/deployment.go\n- internal/controller/deployment_test.go\n- internal/controller/status.go\n- internal/controller/status_test.go\n- internal/controller/memcached_controller.go",
  "stories": [],
  "requirements": [],
  "tasks": [],
  "test_specifications": [],
  "affected_files": [],
  "similar_patterns": [],
  "review_criteria": [],
  "implementation_notes": "",
  "status_history": {
    "proposed": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T15:48:10.849556"
    }
  },
  "elaboration": "\n\nLet me explore the codebase to ground this elaboration in existing patterns and terminology.Serena's language server isn't initialized â€” I'll fall back to direct file reads to ground the elaboration.Now let me check the existing reconcile helper and test patterns.Now I have full codebase context. Here is the refined elaboration:\n\n---\n\n**Size:** ðŸ”¨ medium\n**Category:** backend\n**Priority:** high\n\n## Summary\n\nExtend the Memcached controller to detect changes in referenced SASL and TLS Secrets by computing a SHA-256 hash over their `.data` and storing it as a Pod template annotation (`memcached.c5c3.io/secret-hash`). When the hash changes, the Deployment's Pod template is updated, triggering a Kubernetes rolling restart. A Secret watch via `handler.EnqueueRequestsFromMapFunc` maps Secret change events back to referencing Memcached CRs. A manual restart annotation (`memcached.c5c3.io/restart-trigger`) on the CR provides user-initiated restarts. Missing Secrets are reported via a `Degraded` condition with reason `SecretNotFound`.\n\n## Scope\n\n**Included:**\n- SHA-256 hash computation over referenced SASL + TLS Secret `.data` fields\n- Pod template annotation `memcached.c5c3.io/secret-hash` carrying the combined hash\n- Secret watcher in `SetupWithManager` using `.Watches(&corev1.Secret{}, handler.EnqueueRequestsFromMapFunc(mapFunc))` to map Secret events to owning Memcached CRs\n- Manual restart annotation `memcached.c5c3.io/restart-trigger` read from the Memcached CR and propagated into Pod template annotations\n- `Degraded` condition with reason `SecretNotFound` when a referenced Secret is missing (Deployment still reconciled â€” Kubernetes handles pod-level failures)\n- Unit tests for hash computation, annotation propagation, and map function\n- Integration tests for rolling restart on Secret change and Degraded condition on missing Secret\n\n**Excluded (YAGNI):**\n- Automatic Secret creation or rotation (external concern, e.g. cert-manager)\n- Secret content validation beyond existence (e.g. checking TLS cert validity, SASL password format)\n- Metrics for Secret rotation events\n- Webhook validation of Secret references\n\n## Visualization\n\n```mermaid\nflowchart TD\n    subgraph Watch\n        SEC[\"Secret Change Event\"] --> MAP[\"EnqueueRequestsFromMapFunc\"]\n        MAP --> |\"list MCs referencing Secret\"| RECON[\"Reconcile Memcached\"]\n        MC_CHANGE[\"Memcached CR Change\"] --> RECON\n    end\n\n    subgraph Reconcile\n        RECON --> FETCH[\"Fetch referenced Secrets\"]\n        FETCH --> |\"Secret missing\"| DEG[\"Set Degraded condition\\nreason: SecretNotFound\"]\n        DEG --> DEPLOY\n        FETCH --> |\"Secrets found\"| HASH[\"SHA-256 hash over\\nSASL + TLS Secret .data\"]\n        HASH --> ANN[\"Set Pod template annotation\\nmemcached.c5c3.io/secret-hash\"]\n        ANN --> TRIGGER[\"Read restart-trigger\\nfrom CR annotation\"]\n        TRIGGER --> DEPLOY[\"Update Deployment via\\nreconcileResource\"]\n        DEPLOY --> |\"hash or trigger changed\"| ROLL[\"Rolling Update\"]\n    end\n```\n\n```mermaid\nsequenceDiagram\n    participant S as Secret\n    participant W as Secret Watcher\n    participant C as Controller\n    participant D as Deployment\n    participant P as Pods\n\n    S->>W: Secret .data updated\n    W->>C: Enqueue referencing Memcached CR\n    C->>S: Get Secret, compute SHA-256\n    C->>D: Update Pod template annotation\n    D->>P: Rolling restart with new Pods\n    P->>P: Mount updated Secret volumes\n```\n\n## Key Components\n\n- **`internal/controller/secret.go`** (new): `computeSecretHash(secrets ...*corev1.Secret) string` â€” SHA-256 over sorted `.data` keys/values; `fetchReferencedSecrets(ctx, client, mc) ([]*corev1.Secret, []string)` â€” returns found Secrets + list of missing Secret names; `mapSecretToMemcached(ctx, client, secret) []reconcile.Request` â€” the `EnqueueRequestsFromMapFunc` handler that lists all Memcached CRs in the Secret's namespace and filters those referencing the Secret via `SASLSpec.CredentialsSecretRef` or `TLSSpec.CertificateSecretRef`\n- **`internal/controller/deployment.go`** (modify `constructDeployment`): Accept a `secretHash string` and `restartTrigger string` parameter; set `dep.Spec.Template.ObjectMeta.Annotations[\"memcached.c5c3.io/secret-hash\"]` and `[\"memcached.c5c3.io/restart-trigger\"]` on the Pod template â€” this is the mechanism that triggers the rolling update\n- **`internal/controller/memcached_controller.go`** (modify): Call `fetchReferencedSecrets` + `computeSecretHash` in `reconcileDeployment` before calling `constructDeployment`; read `memcached.c5c3.io/restart-trigger` from `mc.Annotations`; extend `SetupWithManager` with `.Watches(&corev1.Secret{}, handler.EnqueueRequestsFromMapFunc(mapSecretToMemcached))`\n- **`internal/controller/status.go`** (modify): Add `ConditionReasonSecretNotFound = \"SecretNotFound\"` constant; extend `computeConditions` to accept a `missingSecrets []string` parameter â€” when non-empty, set `Degraded=True` with reason `SecretNotFound` and a message listing the missing Secret names\n- **`api/v1alpha1/memcached_types.go`** (no change): Existing `SASLSpec.CredentialsSecretRef` and `TLSSpec.CertificateSecretRef` already provide the references needed; `memcached.c5c3.io/restart-trigger` lives as a CR annotation, no type change required\n- **`internal/controller/secret_test.go`** (new): Unit tests for `computeSecretHash` (deterministic, order-independent), `mapSecretToMemcached` (correct filtering), `fetchReferencedSecrets` (found vs missing)\n- **`internal/controller/deployment_test.go`** (modify): Add cases for secret-hash and restart-trigger annotations on Pod template\n- **`internal/controller/status_test.go`** (modify): Add cases for `SecretNotFound` Degraded condition"
}