{
  "feature_id": "MO-0016",
  "title": "E001: Implement pod security contexts",
  "slug": "e001-implement-pod-security-contexts",
  "status": "prepared",
  "phase": null,
  "summary": "",
  "description": "Apply restrictive pod and container security contexts: runAsNonRoot, readOnlyRootFilesystem, drop ALL capabilities, seccompProfile RuntimeDefault. Follow Kubernetes Pod Security Standards (restricted profile).",
  "stories": [
    {
      "title": "Operator applies pod security context from CR spec to Deployment",
      "role": "cluster operator",
      "want": "the operator to apply spec.security.podSecurityContext to the Deployment pod template so that pod-level security settings (runAsNonRoot, fsGroup, seccompProfile) are enforced",
      "so_that": "Memcached pods comply with Kubernetes Pod Security Standards (restricted profile) and cluster security policies",
      "criteria": [
        "Deployment pod template spec.securityContext is set to spec.security.podSecurityContext when provided",
        "Deployment pod template spec.securityContext is nil when spec.security is nil",
        "Deployment pod template spec.securityContext is nil when spec.security.podSecurityContext is nil",
        "Updating spec.security.podSecurityContext triggers a Deployment update with the new pod security context"
      ]
    },
    {
      "title": "Operator applies container security context to memcached container",
      "role": "cluster operator",
      "want": "the operator to apply spec.security.containerSecurityContext to the memcached container so that container-level security settings (readOnlyRootFilesystem, capabilities, runAsUser) are enforced",
      "so_that": "the memcached container runs with least-privilege settings following the Kubernetes restricted security profile",
      "criteria": [
        "Memcached container has securityContext set to spec.security.containerSecurityContext when provided",
        "Memcached container has nil securityContext when spec.security is nil",
        "Memcached container has nil securityContext when spec.security.containerSecurityContext is nil",
        "Updating spec.security.containerSecurityContext triggers a Deployment update"
      ]
    },
    {
      "title": "Operator applies container security context to exporter sidecar",
      "role": "cluster operator",
      "want": "the operator to apply the same spec.security.containerSecurityContext to the exporter sidecar container when monitoring is enabled",
      "so_that": "all containers in the pod have consistent security settings and the pod passes Pod Security Standards admission",
      "criteria": [
        "Exporter container has the same securityContext as the memcached container when both monitoring and security contexts are configured",
        "Exporter container has nil securityContext when spec.security.containerSecurityContext is nil",
        "Both containers share the same security context values from a single CR field"
      ]
    },
    {
      "title": "Operator removes security contexts when cleared from CR",
      "role": "cluster operator",
      "want": "security contexts to be removed from the Deployment when I remove them from the CR spec",
      "so_that": "I can dynamically adjust security settings without recreating the CR",
      "criteria": [
        "Removing spec.security from the CR clears both pod and container security contexts on the Deployment",
        "Setting spec.security.podSecurityContext to nil clears the pod security context while preserving container security context",
        "Setting spec.security.containerSecurityContext to nil clears container security contexts while preserving pod security context",
        "The Deployment converges to the correct state after clearing"
      ]
    },
    {
      "title": "Operator maintains idempotent reconciliation with security contexts",
      "role": "system",
      "want": "repeated reconciliation with unchanged security spec to produce no Deployment updates",
      "so_that": "unnecessary pod restarts are avoided and the operator is level-triggered",
      "criteria": [
        "Deployment resourceVersion does not change on second reconcile with security contexts configured",
        "Security contexts coexist correctly with anti-affinity, topology spread, graceful shutdown, and monitoring",
        "Deployment correctly converges after drift (manual security context removal)"
      ]
    },
    {
      "title": "Reference documentation for pod security contexts",
      "role": "developer",
      "want": "comprehensive reference documentation for the security context implementation",
      "so_that": "other developers can understand the security context mapping and Kubernetes restricted profile compliance",
      "criteria": [
        "Documentation covers buildPodSecurityContext and buildContainerSecurityContext functions",
        "Documentation includes CRD field mapping to Deployment fields",
        "Documentation includes YAML examples for restricted profile configuration",
        "Documentation follows existing docs/reference/backend/ conventions"
      ]
    }
  ],
  "requirements": [
    {
      "id": "REQ-001",
      "description": "The operator SHALL apply spec.security.podSecurityContext to the Deployment pod template spec.securityContext field",
      "priority": "SHALL",
      "rationale": "Pod-level security context (runAsNonRoot, fsGroup, seccompProfile) must be set on the PodSpec to enforce Kubernetes Pod Security Standards at the pod level",
      "scenarios": [
        {
          "name": "Pod security context applied from CR",
          "when": "a Memcached CR is created with spec.security.podSecurityContext set (e.g. runAsNonRoot=true, seccompProfile=RuntimeDefault)",
          "then": "the reconciled Deployment pod template has spec.securityContext matching the CR value",
          "and_then": [
            "the pod security context includes all fields set in the CR"
          ]
        },
        {
          "name": "No pod security context when security is nil",
          "when": "a Memcached CR is created with spec.security=nil",
          "then": "the reconciled Deployment pod template has nil spec.securityContext",
          "and_then": []
        },
        {
          "name": "No pod security context when podSecurityContext is nil",
          "when": "a Memcached CR is created with spec.security set but spec.security.podSecurityContext=nil",
          "then": "the reconciled Deployment pod template has nil spec.securityContext",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-002",
      "description": "The operator SHALL apply spec.security.containerSecurityContext to the memcached container's securityContext field",
      "priority": "SHALL",
      "rationale": "Container-level security context (readOnlyRootFilesystem, capabilities.drop, runAsUser) must be set per-container to enforce least-privilege at the container level",
      "scenarios": [
        {
          "name": "Container security context applied to memcached container",
          "when": "a Memcached CR is created with spec.security.containerSecurityContext set (e.g. readOnlyRootFilesystem=true, capabilities.drop=[ALL])",
          "then": "the reconciled Deployment memcached container has securityContext matching the CR value",
          "and_then": []
        },
        {
          "name": "No container security context when security is nil",
          "when": "a Memcached CR is created with spec.security=nil",
          "then": "the reconciled Deployment memcached container has nil securityContext",
          "and_then": []
        },
        {
          "name": "No container security context when containerSecurityContext is nil",
          "when": "a Memcached CR is created with spec.security set but spec.security.containerSecurityContext=nil",
          "then": "the reconciled Deployment memcached container has nil securityContext",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-003",
      "description": "The operator SHALL apply spec.security.containerSecurityContext to the exporter sidecar container when monitoring is enabled",
      "priority": "SHALL",
      "rationale": "All containers in a pod must have consistent security contexts to pass Pod Security Standards restricted profile admission; the exporter sidecar must not be a security gap",
      "scenarios": [
        {
          "name": "Container security context applied to exporter sidecar",
          "when": "monitoring is enabled and spec.security.containerSecurityContext is set",
          "then": "the exporter container has the same securityContext as the memcached container",
          "and_then": []
        },
        {
          "name": "No security context on exporter when containerSecurityContext is nil",
          "when": "monitoring is enabled and spec.security.containerSecurityContext is nil",
          "then": "the exporter container has nil securityContext",
          "and_then": []
        },
        {
          "name": "No security context on exporter when security is nil",
          "when": "monitoring is enabled and spec.security is nil",
          "then": "the exporter container has nil securityContext",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-004",
      "description": "The operator SHALL update the Deployment when security contexts are changed on the CR",
      "priority": "SHALL",
      "rationale": "Drift detection must work for security contexts just as it does for replicas, image, and resources — operators must be able to dynamically adjust security settings",
      "scenarios": [
        {
          "name": "Adding security context triggers Deployment update",
          "when": "spec.security.podSecurityContext is added to a CR that previously had no security settings",
          "then": "the Deployment is updated to include the pod security context",
          "and_then": []
        },
        {
          "name": "Removing security context triggers Deployment update",
          "when": "spec.security is set to nil on a CR that had security contexts configured",
          "then": "the Deployment is updated to clear both pod and container security contexts",
          "and_then": []
        },
        {
          "name": "Changing security context values triggers Deployment update",
          "when": "spec.security.containerSecurityContext.runAsUser is changed from 1000 to 65534",
          "then": "the Deployment is updated with the new runAsUser value",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-005",
      "description": "The operator SHALL maintain idempotent reconciliation when security contexts are configured",
      "priority": "SHALL",
      "rationale": "Level-triggered reconciliation must not cause unnecessary Deployment updates and pod restarts when security contexts are unchanged",
      "scenarios": [
        {
          "name": "No-op on second reconcile with security contexts",
          "when": "a Deployment with security contexts exists and reconciliation runs without spec changes",
          "then": "the Deployment resourceVersion does not change",
          "and_then": []
        },
        {
          "name": "Drift correction restores security contexts",
          "when": "security contexts are manually removed from the Deployment",
          "then": "the next reconcile restores the security contexts",
          "and_then": []
        },
        {
          "name": "Deterministic security context output",
          "when": "constructDeployment is called multiple times with the same security spec",
          "then": "the output is identical each time",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-006",
      "description": "Security contexts SHOULD coexist correctly with all other Deployment features (anti-affinity, topology spread, graceful shutdown, monitoring)",
      "priority": "SHOULD",
      "rationale": "Security contexts must not break or interfere with existing HA, lifecycle, and monitoring features",
      "scenarios": [
        {
          "name": "Security contexts with monitoring enabled",
          "when": "both security contexts and monitoring are enabled",
          "then": "the memcached container and exporter container both have security contexts, pod has pod security context",
          "and_then": [
            "monitoring ports, probes, and resources are unaffected"
          ]
        },
        {
          "name": "Security contexts with graceful shutdown",
          "when": "both security contexts and graceful shutdown are enabled",
          "then": "the memcached container has both securityContext and Lifecycle preStop hook",
          "and_then": [
            "terminationGracePeriodSeconds is unaffected"
          ]
        },
        {
          "name": "Security contexts with anti-affinity and topology spread",
          "when": "security contexts, anti-affinity, and topology spread are all enabled",
          "then": "all features are correctly applied to the Deployment",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-007",
      "description": "The buildPodSecurityContext and buildContainerSecurityContext helpers SHALL follow the nil-guard pattern used by other builder functions",
      "priority": "SHALL",
      "rationale": "Consistency with existing patterns (buildAntiAffinity, buildGracefulShutdown, buildExporterContainer) ensures maintainability and predictable behavior",
      "scenarios": [
        {
          "name": "buildPodSecurityContext returns nil when security is nil",
          "when": "mc.Spec.Security is nil",
          "then": "buildPodSecurityContext returns nil",
          "and_then": []
        },
        {
          "name": "buildPodSecurityContext returns nil when podSecurityContext is nil",
          "when": "mc.Spec.Security is set but PodSecurityContext is nil",
          "then": "buildPodSecurityContext returns nil",
          "and_then": []
        },
        {
          "name": "buildContainerSecurityContext returns the configured value",
          "when": "mc.Spec.Security.ContainerSecurityContext is set",
          "then": "buildContainerSecurityContext returns the exact value from the CR",
          "and_then": []
        }
      ]
    },
    {
      "id": "REQ-008",
      "description": "The CRD types SHALL already support PodSecurityContext and ContainerSecurityContext fields in SecuritySpec",
      "priority": "SHALL",
      "rationale": "The SecuritySpec type already includes these fields — no type changes are needed, only deployment construction logic",
      "scenarios": [
        {
          "name": "Existing CRD accepts pod security context",
          "when": "a Memcached CR is created with spec.security.podSecurityContext containing runAsNonRoot, seccompProfile",
          "then": "the CR is accepted by the API server without validation errors",
          "and_then": [
            "the stored CR preserves all security context fields"
          ]
        },
        {
          "name": "Existing CRD accepts container security context",
          "when": "a Memcached CR is created with spec.security.containerSecurityContext containing readOnlyRootFilesystem, capabilities.drop, allowPrivilegeEscalation",
          "then": "the CR is accepted by the API server without validation errors",
          "and_then": []
        },
        {
          "name": "Existing CRD accepts empty security spec",
          "when": "a Memcached CR is created with spec.security={}",
          "then": "the CR is accepted with nil security context fields",
          "and_then": []
        }
      ]
    }
  ],
  "tasks": [
    {
      "id": "1.1",
      "title": "Add buildPodSecurityContext and buildContainerSecurityContext helpers, apply in constructDeployment, and unit tests (REQ-001, REQ-002, REQ-003, REQ-007)",
      "description": "In `internal/controller/deployment.go`: Create `buildPodSecurityContext(mc *Memcached) *corev1.PodSecurityContext` that returns `mc.Spec.Security.PodSecurityContext` when security is configured, or nil otherwise. Create `buildContainerSecurityContext(mc *Memcached) *corev1.SecurityContext` with the same nil-guard pattern. In `constructDeployment`: call `buildPodSecurityContext` and set on `corev1.PodSpec.SecurityContext`. Call `buildContainerSecurityContext` and set on the memcached container's `SecurityContext` field. Also set the same container security context on the exporter sidecar container (in `buildExporterContainer` or after appending it). Add unit tests in `internal/controller/deployment_test.go`: TestBuildPodSecurityContext_WithValue, TestBuildPodSecurityContext_NilSecurity, TestBuildPodSecurityContext_NilPodSecurityContext, TestBuildContainerSecurityContext_WithValue, TestBuildContainerSecurityContext_NilSecurity, TestBuildContainerSecurityContext_NilContainerSecurityContext, TestConstructDeployment_SecurityContexts (verifies pod and container security contexts on the deployment), TestConstructDeployment_SecurityContextsNil (verifies nil when security not set), TestConstructDeployment_SecurityContextsOnExporterSidecar (verifies exporter also gets container security context when monitoring enabled).",
      "level": 1,
      "estimate_minutes": 25,
      "requirements": [
        "REQ-001",
        "REQ-002",
        "REQ-003",
        "REQ-007"
      ]
    },
    {
      "id": "2.1",
      "title": "Integration tests for security contexts via envtest (REQ-001, REQ-002, REQ-003, REQ-004, REQ-005, REQ-006)",
      "description": "In a new file `internal/controller/memcached_security_context_reconcile_test.go` (Ginkgo/Gomega, package controller_test): Add envtest integration tests using existing `reconcileOnce`, `fetchDeployment`, `validMemcached`, `uniqueName` helpers. Test contexts: (1) 'pod and container security contexts applied' - create CR with full restricted profile security contexts (runAsNonRoot=true, readOnlyRootFilesystem=true, capabilities.drop=[ALL], seccompProfile=RuntimeDefault, allowPrivilegeEscalation=false), verify pod securityContext and memcached container securityContext are set correctly; (2) 'no security contexts when security is nil' - verify both are nil; (3) 'only pod security context when containerSecurityContext is nil' - verify pod set, container nil; (4) 'only container security context when podSecurityContext is nil' - verify container set, pod nil; (5) 'security contexts on exporter sidecar' - enable monitoring + security contexts, verify both containers have container security context; (6) 'update security contexts' - create without security, add security contexts, verify applied; then change runAsUser, verify updated; then remove security, verify cleared; (7) 'idempotency with security contexts' - verify resourceVersion unchanged on second reconcile; (8) 'coexistence with all features' - enable anti-affinity, topology spread, graceful shutdown, monitoring, and security contexts, verify all features present on the Deployment.",
      "level": 2,
      "estimate_minutes": 25,
      "requirements": [
        "REQ-001",
        "REQ-002",
        "REQ-003",
        "REQ-004",
        "REQ-005",
        "REQ-006"
      ]
    },
    {
      "id": "3.1",
      "title": "Update sample CR YAML with security context example (REQ-001, REQ-002)",
      "description": "Update `config/samples/memcached_v1alpha1_memcached.yaml` to include a security section demonstrating the Kubernetes restricted profile: `spec.security.podSecurityContext` with `runAsNonRoot: true`, `seccompProfile.type: RuntimeDefault`, `fsGroup: 11211`; and `spec.security.containerSecurityContext` with `readOnlyRootFilesystem: true`, `allowPrivilegeEscalation: false`, `capabilities.drop: [ALL]`. Replace the existing `security: enableNetworkPolicy: true` placeholder (which is invalid for the current CRD schema) with the correct security context fields.",
      "level": 3,
      "estimate_minutes": 10,
      "requirements": [
        "REQ-001",
        "REQ-002"
      ]
    },
    {
      "id": "3.2",
      "title": "Reference documentation for pod security contexts (REQ-001, REQ-002, REQ-003)",
      "description": "Create `docs/reference/backend/pod-security-contexts.md` documenting: overview of the feature and Kubernetes Pod Security Standards restricted profile, the `buildPodSecurityContext` and `buildContainerSecurityContext` functions, CRD field mapping (`spec.security.podSecurityContext` -> `PodSpec.SecurityContext`, `spec.security.containerSecurityContext` -> Container.SecurityContext on all containers), examples showing a minimal security configuration, a full restricted profile configuration, and monitoring with security contexts. Follow the existing pattern in `docs/reference/backend/deployment-reconciliation.md` for structure and formatting (overview, function documentation, field mapping tables, YAML examples).",
      "level": 3,
      "estimate_minutes": 15,
      "requirements": [
        "REQ-001",
        "REQ-002",
        "REQ-003"
      ]
    }
  ],
  "test_specifications": [
    {
      "test_file": "internal/controller/deployment_test.go",
      "test_function": "TestBuildPodSecurityContext_WithValue",
      "story": "Operator applies pod security context from CR spec to Deployment",
      "expected": "Returns the PodSecurityContext from spec.security.podSecurityContext when set",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "internal/controller/deployment_test.go",
      "test_function": "TestBuildPodSecurityContext_NilSecurity",
      "story": "Operator applies pod security context from CR spec to Deployment",
      "expected": "Returns nil when spec.security is nil",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "internal/controller/deployment_test.go",
      "test_function": "TestBuildPodSecurityContext_NilPodSecurityContext",
      "story": "Operator applies pod security context from CR spec to Deployment",
      "expected": "Returns nil when spec.security.podSecurityContext is nil",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "internal/controller/deployment_test.go",
      "test_function": "TestBuildContainerSecurityContext_WithValue",
      "story": "Operator applies container security context to memcached container",
      "expected": "Returns the SecurityContext from spec.security.containerSecurityContext when set",
      "requirement_id": "REQ-002"
    },
    {
      "test_file": "internal/controller/deployment_test.go",
      "test_function": "TestBuildContainerSecurityContext_NilSecurity",
      "story": "Operator applies container security context to memcached container",
      "expected": "Returns nil when spec.security is nil",
      "requirement_id": "REQ-002"
    },
    {
      "test_file": "internal/controller/deployment_test.go",
      "test_function": "TestBuildContainerSecurityContext_NilContainerSecurityContext",
      "story": "Operator applies container security context to memcached container",
      "expected": "Returns nil when spec.security.containerSecurityContext is nil",
      "requirement_id": "REQ-002"
    },
    {
      "test_file": "internal/controller/deployment_test.go",
      "test_function": "TestConstructDeployment_SecurityContexts",
      "story": "Operator applies pod security context from CR spec to Deployment",
      "expected": "Deployment pod template has podSecurityContext and memcached container has containerSecurityContext when both are configured",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "internal/controller/deployment_test.go",
      "test_function": "TestConstructDeployment_SecurityContextsNil",
      "story": "Operator applies pod security context from CR spec to Deployment",
      "expected": "Deployment pod template has nil podSecurityContext and container has nil securityContext when security is nil",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "internal/controller/deployment_test.go",
      "test_function": "TestConstructDeployment_SecurityContextsOnExporterSidecar",
      "story": "Operator applies container security context to exporter sidecar",
      "expected": "Both memcached and exporter containers have containerSecurityContext when monitoring and security are enabled",
      "requirement_id": "REQ-003"
    },
    {
      "test_file": "internal/controller/memcached_security_context_reconcile_test.go",
      "test_function": "should apply pod and container security contexts to Deployment",
      "story": "Operator applies pod security context from CR spec to Deployment",
      "expected": "Full integration: Deployment has pod and container security contexts matching CR spec after reconciliation",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "internal/controller/memcached_security_context_reconcile_test.go",
      "test_function": "should have nil security contexts when security is nil",
      "story": "Operator removes security contexts when cleared from CR",
      "expected": "Deployment has nil pod and container security contexts when spec.security is nil",
      "requirement_id": "REQ-001"
    },
    {
      "test_file": "internal/controller/memcached_security_context_reconcile_test.go",
      "test_function": "should apply security contexts to exporter sidecar",
      "story": "Operator applies container security context to exporter sidecar",
      "expected": "Both memcached and exporter containers have container security context when monitoring enabled",
      "requirement_id": "REQ-003"
    },
    {
      "test_file": "internal/controller/memcached_security_context_reconcile_test.go",
      "test_function": "should update Deployment when security contexts change",
      "story": "Operator removes security contexts when cleared from CR",
      "expected": "Adding, changing, and removing security contexts triggers Deployment updates",
      "requirement_id": "REQ-004"
    },
    {
      "test_file": "internal/controller/memcached_security_context_reconcile_test.go",
      "test_function": "should be idempotent with security contexts",
      "story": "Operator maintains idempotent reconciliation with security contexts",
      "expected": "ResourceVersion unchanged on second reconcile with security contexts configured",
      "requirement_id": "REQ-005"
    },
    {
      "test_file": "internal/controller/memcached_security_context_reconcile_test.go",
      "test_function": "should coexist with all features",
      "story": "Operator maintains idempotent reconciliation with security contexts",
      "expected": "All features (security contexts, monitoring, anti-affinity, topology spread, graceful shutdown) work together",
      "requirement_id": "REQ-006"
    }
  ],
  "affected_files": [],
  "similar_patterns": [],
  "review_criteria": [
    "All SHALL requirements (REQ-001 to REQ-005, REQ-007, REQ-008) have corresponding passing unit and integration tests",
    "buildPodSecurityContext and buildContainerSecurityContext follow the nil-guard pattern of buildAntiAffinity/buildGracefulShutdown (return nil when security not configured)",
    "constructDeployment produces deterministic output — idempotency verified by resourceVersion checks in envtest",
    "Container security context is applied to ALL containers in the pod (memcached + exporter when monitoring enabled)",
    "No breaking changes to existing tests — all pre-existing deployment_test.go and reconcile test files still pass",
    "No changes to api/v1alpha1/memcached_types.go — SecuritySpec already has the required fields",
    "Code passes golangci-lint and go vet without errors",
    "Security context fields are passed through from CR spec (not hardcoded) — the operator does not enforce specific values, it applies what the user configures",
    "Reference documentation created at docs/reference/backend/pod-security-contexts.md with function docs, field mapping, and YAML examples",
    "Sample CR at config/samples/memcached_v1alpha1_memcached.yaml updated with valid security context example"
  ],
  "implementation_notes": "Architecture: Add two helper functions in `deployment.go` following the existing nil-guard pattern: `buildPodSecurityContext(mc *Memcached) *corev1.PodSecurityContext` and `buildContainerSecurityContext(mc *Memcached) *corev1.SecurityContext`. Both check `mc.Spec.Security == nil` first, then check the specific sub-field. They return the CR value directly (passthrough, not defaulting — defaulting is the future webhook's responsibility per S021). In `constructDeployment`: call `buildPodSecurityContext` and assign to `PodSpec.SecurityContext`. Call `buildContainerSecurityContext` and assign to the memcached container's `SecurityContext`. For the exporter sidecar, the container security context must also be applied — modify `buildExporterContainer` to accept the container security context or apply it after building the container (the second approach is simpler: build the container, then set SecurityContext on it before appending to the containers slice). No changes to `api/v1alpha1/memcached_types.go` are needed — `SecuritySpec` already has `PodSecurityContext *corev1.PodSecurityContext` and `ContainerSecurityContext *corev1.SecurityContext`. No changes to `memcached_controller.go` — the existing `reconcileDeployment` calls `constructDeployment` which will include the new security context logic. The sample CR currently has `security: enableNetworkPolicy: true` which does not match the current CRD schema — this should be corrected to use valid security context fields. Key design decision: the operator passes through whatever security context the user provides. It does NOT hardcode restrictive defaults. The PLAN.md mentions restrictive defaults as part of S016, but those defaults belong in the defaulting webhook (S021). This feature implements the plumbing to apply user-provided security contexts to the Deployment.",
  "status_history": {
    "draft": {
      "github_account": "berendt",
      "timestamp": "2026-02-18T20:22:08.425099"
    },
    "preparing": {
      "github_account": "berendt",
      "timestamp": "2026-02-19T21:41:19.718371"
    },
    "prepared": {
      "github_account": "berendt",
      "timestamp": "2026-02-19T21:46:22.939027"
    }
  },
  "execution_history": [
    {
      "run_id": "63f9978c-95c3-4f58-99b9-91426f97061d",
      "timestamp": "2026-02-19T21:46:22.939053",
      "total_duration": 299.29095220565796,
      "status": "completed",
      "timings": [
        {
          "name": "prepare",
          "duration": 299.29095220565796,
          "type": "prepare",
          "status": "done"
        }
      ]
    }
  ]
}