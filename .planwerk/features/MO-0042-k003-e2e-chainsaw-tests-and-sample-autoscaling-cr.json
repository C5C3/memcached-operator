{
  "feature_id": "MO-0042",
  "title": "K003: E2E Chainsaw tests and sample autoscaling CR",
  "slug": "k003-e2e-chainsaw-tests-and-sample-autoscaling-cr",
  "status": "proposed",
  "phase": null,
  "summary": "",
  "description": "**Size:** üì¶ medium\n**Category:** testing\n**Priority:** high\n**Source:** Proposed for 'Horizontal Pod Autoscaling\n\nNew spec.autoscaling'\n\nCreate Chainsaw E2E test cases following existing test patterns: (1) autoscaling enable test - apply Memcached CR with autoscaling.enabled=true, assert HPA is created with correct scaleTargetRef, metrics, and behavior defaults; (2) autoscaling disable test - update CR to disable autoscaling and set spec.replicas, assert HPA is deleted and Deployment replicas are set; (3) mutual exclusivity rejection test - apply CR with both spec.replicas and autoscaling.enabled=true, assert admission webhook rejects it; (4) autoscaling update test - modify metrics/behavior on existing autoscaled CR, assert HPA is updated. Create sample CR at config/samples/memcached_v1alpha1_autoscaling.yaml demonstrating the autoscaling block with enabled=true, minReplicas=2, maxReplicas=10, and the default CPU metric.\n\n**Rationale:** E2E tests validate the full lifecycle in a real cluster environment, catching integration issues that unit and envtest tests miss (e.g., webhook certificate wiring, RBAC permissions, HPA controller interaction). The sample CR serves as documentation and is used by the Chainsaw tests. Without E2E coverage, regressions in the admission-to-reconciliation pipeline would go undetected.\n\n**Affected Areas:**\n- test/e2e/\n- config/samples/memcached_v1alpha1_autoscaling.yaml",
  "stories": [],
  "requirements": [],
  "tasks": [],
  "test_specifications": [],
  "affected_files": [],
  "similar_patterns": [],
  "review_criteria": [],
  "implementation_notes": "",
  "status_history": {
    "proposed": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T16:10:15.870116"
    }
  },
  "elaboration": "\n\n**Size:** üèóÔ∏è large\n**Category:** backend (Kubernetes operator)\n**Priority:** high\n\n## Summary\n\nAdd an optional `spec.autoscaling` block to the Memcached CRD that enables the operator to reconcile a Kubernetes `HorizontalPodAutoscaler` (autoscaling/v2) targeting the managed Deployment. When autoscaling is active, the HPA owns replica count decisions and `spec.replicas` is ignored. The feature includes cache-friendly defaults (80% CPU target, 300s scaleDown stabilization) and mutual exclusivity validation via the existing webhook infrastructure.\n\n## Scope\n\n**Included:**\n- New `AutoscalingSpec` struct in `api/v1alpha1/memcached_types.go` with fields: `Enabled`, `MinReplicas`, `MaxReplicas`, `Metrics []autoscalingv2.MetricSpec`, `Behavior *autoscalingv2.HorizontalPodAutoscalerBehavior`\n- New optional `*AutoscalingSpec` field on `MemcachedSpec`\n- Defaulting webhook: inject 80% CPU utilization metric and 300s scaleDown stabilization when autoscaling enabled but fields omitted\n- Validation webhook: reject CRs where both `spec.replicas` is set and `autoscaling.enabled=true`; validate `minReplicas <= maxReplicas`; reject CPU metric without `resources.requests.cpu` on the Memcached container\n- New `reconcileHPA()` in `internal/controller/hpa.go` following existing `reconcileResource`/`deleteOwnedResource` pattern\n- HPA deletion when `autoscaling.enabled=false` (matching PDB/ServiceMonitor/NetworkPolicy pattern), restoring operator control via `spec.replicas`\n- Skip setting `spec.replicas` on Deployment when autoscaling is active\n- RBAC marker for `autoscaling/v2` HorizontalPodAutoscalers\n- Status condition updates reflecting HPA-managed scaling\n- HPA reconciliation counter in existing per-resource metrics\n- Unit tests (types, webhook defaults, webhook validation, HPA construction)\n- Integration tests (envtest: HPA create/update/delete lifecycle)\n- E2E Chainsaw tests (autoscaling enable/disable, mutual exclusivity rejection)\n- Sample CR: `memcached_v1alpha1_autoscaling.yaml`\n\n**Excluded:**\n- Vertical Pod Autoscaler (VPA) ‚Äî YAGNI, separate concern\n- Operator-specific metric abstractions ‚Äî pass-through `MetricSpec` is sufficient\n- KEDA `ScaledObject` support ‚Äî YAGNI, different autoscaling paradigm\n- Automatic CPU request injection ‚Äî user responsibility, operator only validates\n- HPA status mirroring into Memcached status ‚Äî YAGNI, users can inspect HPA directly\n\n## Visualization\n\n```mermaid\nflowchart TD\n    CR[\"Memcached CR\"] --> WH[\"Webhook\"]\n\n    subgraph WEBHOOK[\"Admission Webhooks\"]\n        MUT[\"Mutating: default metrics + behavior\"]\n        VAL[\"Validating: replicas vs autoscaling exclusivity\"]\n        MUT --> VAL\n    end\n\n    WH --> MUT\n    VAL --> R[\"Reconciler\"]\n\n    R --> D[\"reconcileDeployment\"]\n    R --> S[\"reconcileService\"]\n    R --> PDB[\"reconcilePDB\"]\n    R --> SM[\"reconcileServiceMonitor\"]\n    R --> NP[\"reconcileNetworkPolicy\"]\n    R --> HPA[\"reconcileHPA #40;NEW#41;\"]\n    R --> ST[\"reconcileStatus\"]\n\n    HPA -->|\"enabled=true\"| UPSERT[\"Create/Update HPA\"]\n    HPA -->|\"enabled=false\"| DEL[\"Delete HPA\"]\n\n    UPSERT --> HPAOBJ[\"HorizontalPodAutoscaler v2\"]\n    HPAOBJ -->|\"scaleTargetRef\"| DEP[\"Memcached Deployment\"]\n```\n\n```mermaid\nsequenceDiagram\n    participant U as User\n    participant WH as Webhook\n    participant RC as Reconciler\n    participant K8s as Kubernetes API\n    participant HPAC as HPA Controller\n\n    U->>WH: Create Memcached CR with autoscaling\n    WH->>WH: Default metrics 80% CPU, 300s stabilization\n    WH->>WH: Validate no spec.replicas conflict\n    WH-->>RC: Admitted CR\n\n    RC->>K8s: CreateOrUpdate Deployment #40;no replicas field#41;\n    RC->>K8s: CreateOrUpdate HPA targeting Deployment\n    K8s-->>RC: HPA ready\n\n    HPAC->>K8s: Read pod CPU metrics\n    HPAC->>K8s: Scale Deployment replicas\n    Note over HPAC,K8s: scaleDown stabilization 300s\n\n    U->>WH: Update CR: disable autoscaling, set replicas=3\n    WH-->>RC: Admitted CR\n    RC->>K8s: Delete HPA\n    RC->>K8s: Update Deployment replicas=3\n```\n\n```mermaid\nstateDiagram-v2\n    [*] --> FixedReplicas: spec.replicas set\n    [*] --> Autoscaling: autoscaling.enabled=true\n\n    FixedReplicas --> Autoscaling: enable autoscaling + remove replicas\n    Autoscaling --> FixedReplicas: disable autoscaling + set replicas\n\n    state Autoscaling {\n        [*] --> HPACreated\n        HPACreated --> HPAUpdated: spec change\n        HPAUpdated --> HPAUpdated: spec change\n    }\n\n    state FixedReplicas {\n        [*] --> HPADeleted\n        HPADeleted --> DeploymentScaled: reconcile\n    }\n```\n\n## Key Components\n\n- **`AutoscalingSpec`** (`api/v1alpha1/memcached_types.go`): New struct ‚Äî `Enabled bool`, `MinReplicas *int32`, `MaxReplicas int32`, `Metrics []autoscalingv2.MetricSpec`, `Behavior *autoscalingv2.HorizontalPodAutoscalerBehavior`\n- **`MemcachedSpec.Autoscaling`** (`api/v1alpha1/memcached_types.go`): New optional `*AutoscalingSpec` field\n- **Defaulting webhook** (`api/v1alpha1/memcached_webhook.go`): Inject default CPU 80% metric and 300s scaleDown stabilization when autoscaling enabled but fields omitted\n- **Validation webhook** (`api/v1alpha1/memcached_validation_webhook.go`): Mutual exclusivity check (replicas + autoscaling), `min <= max`, CPU requests presence when CPU metric used\n- **`reconcileHPA()`** (`internal/controller/hpa.go`): New file ‚Äî constructs `autoscalingv2.HorizontalPodAutoscaler`, uses `reconcileResource`/`deleteOwnedResource` helpers\n- **`deployment.go` update** (`internal/controller/deployment.go`): Skip setting `spec.replicas` on Deployment when autoscaling is active\n- **RBAC marker** (`internal/controller/memcached_controller.go`): `+kubebuilder:rbac:groups=autoscaling,resources=horizontalpodautoscalers,verbs=get;list;watch;create;update;patch;delete`\n- **Metrics** (`internal/metrics/metrics.go`): HPA reconciliation counter added to existing per-resource metrics\n- **Sample CR** (`config/samples/memcached_v1alpha1_autoscaling.yaml`): Example with autoscaling block enabled"
}