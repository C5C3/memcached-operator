{
  "feature_id": "MO-0039",
  "title": "J003: Integration tests for Secret rotation and manual restart flows",
  "slug": "j003-integration-tests-for-secret-rotation-and",
  "status": "proposed",
  "phase": null,
  "summary": "",
  "description": "**Size:** ðŸ“¦ medium\n**Category:** testing\n**Priority:** high\n**Source:** Proposed for 'Secret Rotation & Rolling Restart\n\n  Automatic'\n\nCreate integration tests using the existing envtest setup to validate the complete Secret rotation and restart flow end-to-end:\n\n**Secret rotation rolling restart test:**\n1. Create a Memcached CR with SASL and/or TLS Secret references\n2. Create the referenced Secrets with initial data\n3. Verify Deployment is created with `memcached.c5c3.io/secret-hash` annotation containing the correct hash\n4. Update the Secret's `.data` field\n5. Verify the controller re-reconciles and updates the Deployment's Pod template annotation with the new hash\n6. Verify the Deployment's Pod template generation changes (indicating a rolling update would be triggered)\n\n**Missing Secret Degraded condition test:**\n1. Create a Memcached CR referencing a Secret that does not exist\n2. Verify the Memcached CR status has `Degraded=True` with reason `SecretNotFound` and the missing Secret name in the message\n3. Create the missing Secret\n4. Verify the Degraded condition is removed on next reconciliation\n\n**Manual restart trigger test:**\n1. Create a Memcached CR with Secrets, note the initial Pod template generation\n2. Add/update annotation `memcached.c5c3.io/restart-trigger` on the CR (e.g., set to a timestamp)\n3. Verify the Deployment's Pod template annotation is updated with the trigger value\n4. Verify the Pod template generation changes\n\n**Secret watch filtering test:**\n1. Create two Memcached CRs â€” one referencing SecretA, one referencing SecretB\n2. Update SecretA\n3. Verify only the first CR is re-reconciled (not the second)\n\n**Rationale:** Unit tests alone cannot verify the complete reconciliation loop including Secret watches, status updates, and Deployment mutations working together. Integration tests with envtest validate that the Secret watcher correctly triggers reconciliation, the hash is recomputed, and the Deployment is updated â€” the actual user-facing behavior. Without these tests, regressions in the watch-to-reconcile-to-deploy chain would go undetected.\n\n**Affected Areas:**\n- internal/controller/memcached_controller_test.go\n- internal/controller/suite_test.go",
  "stories": [],
  "requirements": [],
  "tasks": [],
  "test_specifications": [],
  "affected_files": [],
  "similar_patterns": [],
  "review_criteria": [],
  "implementation_notes": "",
  "status_history": {
    "proposed": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T15:48:10.850127"
    }
  },
  "elaboration": "\n\nLet me explore the codebase to ground this elaboration in existing patterns and terminology.Serena's language server isn't initialized â€” I'll fall back to direct file reads to ground the elaboration.Now let me check the existing reconcile helper and test patterns.Now I have full codebase context. Here is the refined elaboration:\n\n---\n\n**Size:** ðŸ”¨ medium\n**Category:** backend\n**Priority:** high\n\n## Summary\n\nExtend the Memcached controller to detect changes in referenced SASL and TLS Secrets by computing a SHA-256 hash over their `.data` and storing it as a Pod template annotation (`memcached.c5c3.io/secret-hash`). When the hash changes, the Deployment's Pod template is updated, triggering a Kubernetes rolling restart. A Secret watch via `handler.EnqueueRequestsFromMapFunc` maps Secret change events back to referencing Memcached CRs. A manual restart annotation (`memcached.c5c3.io/restart-trigger`) on the CR provides user-initiated restarts. Missing Secrets are reported via a `Degraded` condition with reason `SecretNotFound`.\n\n## Scope\n\n**Included:**\n- SHA-256 hash computation over referenced SASL + TLS Secret `.data` fields\n- Pod template annotation `memcached.c5c3.io/secret-hash` carrying the combined hash\n- Secret watcher in `SetupWithManager` using `.Watches(&corev1.Secret{}, handler.EnqueueRequestsFromMapFunc(mapFunc))` to map Secret events to owning Memcached CRs\n- Manual restart annotation `memcached.c5c3.io/restart-trigger` read from the Memcached CR and propagated into Pod template annotations\n- `Degraded` condition with reason `SecretNotFound` when a referenced Secret is missing (Deployment still reconciled â€” Kubernetes handles pod-level failures)\n- Unit tests for hash computation, annotation propagation, and map function\n- Integration tests for rolling restart on Secret change and Degraded condition on missing Secret\n\n**Excluded (YAGNI):**\n- Automatic Secret creation or rotation (external concern, e.g. cert-manager)\n- Secret content validation beyond existence (e.g. checking TLS cert validity, SASL password format)\n- Metrics for Secret rotation events\n- Webhook validation of Secret references\n\n## Visualization\n\n```mermaid\nflowchart TD\n    subgraph Watch\n        SEC[\"Secret Change Event\"] --> MAP[\"EnqueueRequestsFromMapFunc\"]\n        MAP --> |\"list MCs referencing Secret\"| RECON[\"Reconcile Memcached\"]\n        MC_CHANGE[\"Memcached CR Change\"] --> RECON\n    end\n\n    subgraph Reconcile\n        RECON --> FETCH[\"Fetch referenced Secrets\"]\n        FETCH --> |\"Secret missing\"| DEG[\"Set Degraded condition\\nreason: SecretNotFound\"]\n        DEG --> DEPLOY\n        FETCH --> |\"Secrets found\"| HASH[\"SHA-256 hash over\\nSASL + TLS Secret .data\"]\n        HASH --> ANN[\"Set Pod template annotation\\nmemcached.c5c3.io/secret-hash\"]\n        ANN --> TRIGGER[\"Read restart-trigger\\nfrom CR annotation\"]\n        TRIGGER --> DEPLOY[\"Update Deployment via\\nreconcileResource\"]\n        DEPLOY --> |\"hash or trigger changed\"| ROLL[\"Rolling Update\"]\n    end\n```\n\n```mermaid\nsequenceDiagram\n    participant S as Secret\n    participant W as Secret Watcher\n    participant C as Controller\n    participant D as Deployment\n    participant P as Pods\n\n    S->>W: Secret .data updated\n    W->>C: Enqueue referencing Memcached CR\n    C->>S: Get Secret, compute SHA-256\n    C->>D: Update Pod template annotation\n    D->>P: Rolling restart with new Pods\n    P->>P: Mount updated Secret volumes\n```\n\n## Key Components\n\n- **`internal/controller/secret.go`** (new): `computeSecretHash(secrets ...*corev1.Secret) string` â€” SHA-256 over sorted `.data` keys/values; `fetchReferencedSecrets(ctx, client, mc) ([]*corev1.Secret, []string)` â€” returns found Secrets + list of missing Secret names; `mapSecretToMemcached(ctx, client, secret) []reconcile.Request` â€” the `EnqueueRequestsFromMapFunc` handler that lists all Memcached CRs in the Secret's namespace and filters those referencing the Secret via `SASLSpec.CredentialsSecretRef` or `TLSSpec.CertificateSecretRef`\n- **`internal/controller/deployment.go`** (modify `constructDeployment`): Accept a `secretHash string` and `restartTrigger string` parameter; set `dep.Spec.Template.ObjectMeta.Annotations[\"memcached.c5c3.io/secret-hash\"]` and `[\"memcached.c5c3.io/restart-trigger\"]` on the Pod template â€” this is the mechanism that triggers the rolling update\n- **`internal/controller/memcached_controller.go`** (modify): Call `fetchReferencedSecrets` + `computeSecretHash` in `reconcileDeployment` before calling `constructDeployment`; read `memcached.c5c3.io/restart-trigger` from `mc.Annotations`; extend `SetupWithManager` with `.Watches(&corev1.Secret{}, handler.EnqueueRequestsFromMapFunc(mapSecretToMemcached))`\n- **`internal/controller/status.go`** (modify): Add `ConditionReasonSecretNotFound = \"SecretNotFound\"` constant; extend `computeConditions` to accept a `missingSecrets []string` parameter â€” when non-empty, set `Degraded=True` with reason `SecretNotFound` and a message listing the missing Secret names\n- **`api/v1alpha1/memcached_types.go`** (no change): Existing `SASLSpec.CredentialsSecretRef` and `TLSSpec.CertificateSecretRef` already provide the references needed; `memcached.c5c3.io/restart-trigger` lives as a CR annotation, no type change required\n- **`internal/controller/secret_test.go`** (new): Unit tests for `computeSecretHash` (deterministic, order-independent), `mapSecretToMemcached` (correct filtering), `fetchReferencedSecrets` (found vs missing)\n- **`internal/controller/deployment_test.go`** (modify): Add cases for secret-hash and restart-trigger annotations on Pod template\n- **`internal/controller/status_test.go`** (modify): Add cases for `SecretNotFound` Degraded condition"
}