{
  "feature_id": "MO-0041",
  "title": "K002: HPA reconciliation controller and deployment integration",
  "slug": "k002-hpa-reconciliation-controller-and-deployment",
  "status": "proposed",
  "phase": null,
  "summary": "",
  "description": "**Size:** üèóÔ∏è large\n**Category:** backend\n**Priority:** critical\n**Source:** Proposed for 'Horizontal Pod Autoscaling\n\nNew spec.autoscaling'\n\nCreate internal/controller/hpa.go with reconcileHPA() following the existing reconcileResource/deleteOwnedResource helper pattern used by PDB, ServiceMonitor, and NetworkPolicy. When autoscaling.enabled=true: construct autoscalingv2.HorizontalPodAutoscaler with scaleTargetRef pointing to the managed Deployment, using spec.autoscaling.metrics, behavior, minReplicas, maxReplicas; create or update via reconcileResource with owner references. When autoscaling.enabled=false or autoscaling is nil: delete the HPA via deleteOwnedResource. Update internal/controller/deployment.go to skip setting spec.replicas on the Deployment when autoscaling is active, preventing operator/HPA conflicts. Add RBAC marker to internal/controller/memcached_controller.go: +kubebuilder:rbac:groups=autoscaling,resources=horizontalpodautoscalers,verbs=get;list;watch;create;update;patch;delete. Wire reconcileHPA() call into the main reconciliation loop in memcached_controller.go. Add HPA reconciliation counter to internal/metrics/metrics.go matching existing per-resource metric pattern. Add status condition updates reflecting HPA-managed scaling state. Write envtest integration tests covering: HPA creation when autoscaling enabled, HPA update on spec change, HPA deletion when autoscaling disabled, Deployment has no replicas field when autoscaling active, Deployment gets replicas restored when autoscaling disabled.\n\n**Rationale:** This is the core business logic that actually creates and manages the HPA resource. It must follow established patterns (reconcileResource/deleteOwnedResource) for consistency and to leverage existing error handling, owner reference management, and metrics. The deployment integration is critical to prevent the operator from fighting the HPA over replica count, which would cause scaling instability.\n\n**Affected Areas:**\n- internal/controller/hpa.go\n- internal/controller/deployment.go\n- internal/controller/memcached_controller.go\n- internal/metrics/metrics.go\n- internal/controller/memcached_controller_test.go",
  "stories": [],
  "requirements": [],
  "tasks": [],
  "test_specifications": [],
  "affected_files": [],
  "similar_patterns": [],
  "review_criteria": [],
  "implementation_notes": "",
  "status_history": {
    "proposed": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T16:10:15.869536"
    }
  },
  "elaboration": "\n\n**Size:** üèóÔ∏è large\n**Category:** backend (Kubernetes operator)\n**Priority:** high\n\n## Summary\n\nAdd an optional `spec.autoscaling` block to the Memcached CRD that enables the operator to reconcile a Kubernetes `HorizontalPodAutoscaler` (autoscaling/v2) targeting the managed Deployment. When autoscaling is active, the HPA owns replica count decisions and `spec.replicas` is ignored. The feature includes cache-friendly defaults (80% CPU target, 300s scaleDown stabilization) and mutual exclusivity validation via the existing webhook infrastructure.\n\n## Scope\n\n**Included:**\n- New `AutoscalingSpec` struct in `api/v1alpha1/memcached_types.go` with fields: `Enabled`, `MinReplicas`, `MaxReplicas`, `Metrics []autoscalingv2.MetricSpec`, `Behavior *autoscalingv2.HorizontalPodAutoscalerBehavior`\n- New optional `*AutoscalingSpec` field on `MemcachedSpec`\n- Defaulting webhook: inject 80% CPU utilization metric and 300s scaleDown stabilization when autoscaling enabled but fields omitted\n- Validation webhook: reject CRs where both `spec.replicas` is set and `autoscaling.enabled=true`; validate `minReplicas <= maxReplicas`; reject CPU metric without `resources.requests.cpu` on the Memcached container\n- New `reconcileHPA()` in `internal/controller/hpa.go` following existing `reconcileResource`/`deleteOwnedResource` pattern\n- HPA deletion when `autoscaling.enabled=false` (matching PDB/ServiceMonitor/NetworkPolicy pattern), restoring operator control via `spec.replicas`\n- Skip setting `spec.replicas` on Deployment when autoscaling is active\n- RBAC marker for `autoscaling/v2` HorizontalPodAutoscalers\n- Status condition updates reflecting HPA-managed scaling\n- HPA reconciliation counter in existing per-resource metrics\n- Unit tests (types, webhook defaults, webhook validation, HPA construction)\n- Integration tests (envtest: HPA create/update/delete lifecycle)\n- E2E Chainsaw tests (autoscaling enable/disable, mutual exclusivity rejection)\n- Sample CR: `memcached_v1alpha1_autoscaling.yaml`\n\n**Excluded:**\n- Vertical Pod Autoscaler (VPA) ‚Äî YAGNI, separate concern\n- Operator-specific metric abstractions ‚Äî pass-through `MetricSpec` is sufficient\n- KEDA `ScaledObject` support ‚Äî YAGNI, different autoscaling paradigm\n- Automatic CPU request injection ‚Äî user responsibility, operator only validates\n- HPA status mirroring into Memcached status ‚Äî YAGNI, users can inspect HPA directly\n\n## Visualization\n\n```mermaid\nflowchart TD\n    CR[\"Memcached CR\"] --> WH[\"Webhook\"]\n\n    subgraph WEBHOOK[\"Admission Webhooks\"]\n        MUT[\"Mutating: default metrics + behavior\"]\n        VAL[\"Validating: replicas vs autoscaling exclusivity\"]\n        MUT --> VAL\n    end\n\n    WH --> MUT\n    VAL --> R[\"Reconciler\"]\n\n    R --> D[\"reconcileDeployment\"]\n    R --> S[\"reconcileService\"]\n    R --> PDB[\"reconcilePDB\"]\n    R --> SM[\"reconcileServiceMonitor\"]\n    R --> NP[\"reconcileNetworkPolicy\"]\n    R --> HPA[\"reconcileHPA #40;NEW#41;\"]\n    R --> ST[\"reconcileStatus\"]\n\n    HPA -->|\"enabled=true\"| UPSERT[\"Create/Update HPA\"]\n    HPA -->|\"enabled=false\"| DEL[\"Delete HPA\"]\n\n    UPSERT --> HPAOBJ[\"HorizontalPodAutoscaler v2\"]\n    HPAOBJ -->|\"scaleTargetRef\"| DEP[\"Memcached Deployment\"]\n```\n\n```mermaid\nsequenceDiagram\n    participant U as User\n    participant WH as Webhook\n    participant RC as Reconciler\n    participant K8s as Kubernetes API\n    participant HPAC as HPA Controller\n\n    U->>WH: Create Memcached CR with autoscaling\n    WH->>WH: Default metrics 80% CPU, 300s stabilization\n    WH->>WH: Validate no spec.replicas conflict\n    WH-->>RC: Admitted CR\n\n    RC->>K8s: CreateOrUpdate Deployment #40;no replicas field#41;\n    RC->>K8s: CreateOrUpdate HPA targeting Deployment\n    K8s-->>RC: HPA ready\n\n    HPAC->>K8s: Read pod CPU metrics\n    HPAC->>K8s: Scale Deployment replicas\n    Note over HPAC,K8s: scaleDown stabilization 300s\n\n    U->>WH: Update CR: disable autoscaling, set replicas=3\n    WH-->>RC: Admitted CR\n    RC->>K8s: Delete HPA\n    RC->>K8s: Update Deployment replicas=3\n```\n\n```mermaid\nstateDiagram-v2\n    [*] --> FixedReplicas: spec.replicas set\n    [*] --> Autoscaling: autoscaling.enabled=true\n\n    FixedReplicas --> Autoscaling: enable autoscaling + remove replicas\n    Autoscaling --> FixedReplicas: disable autoscaling + set replicas\n\n    state Autoscaling {\n        [*] --> HPACreated\n        HPACreated --> HPAUpdated: spec change\n        HPAUpdated --> HPAUpdated: spec change\n    }\n\n    state FixedReplicas {\n        [*] --> HPADeleted\n        HPADeleted --> DeploymentScaled: reconcile\n    }\n```\n\n## Key Components\n\n- **`AutoscalingSpec`** (`api/v1alpha1/memcached_types.go`): New struct ‚Äî `Enabled bool`, `MinReplicas *int32`, `MaxReplicas int32`, `Metrics []autoscalingv2.MetricSpec`, `Behavior *autoscalingv2.HorizontalPodAutoscalerBehavior`\n- **`MemcachedSpec.Autoscaling`** (`api/v1alpha1/memcached_types.go`): New optional `*AutoscalingSpec` field\n- **Defaulting webhook** (`api/v1alpha1/memcached_webhook.go`): Inject default CPU 80% metric and 300s scaleDown stabilization when autoscaling enabled but fields omitted\n- **Validation webhook** (`api/v1alpha1/memcached_validation_webhook.go`): Mutual exclusivity check (replicas + autoscaling), `min <= max`, CPU requests presence when CPU metric used\n- **`reconcileHPA()`** (`internal/controller/hpa.go`): New file ‚Äî constructs `autoscalingv2.HorizontalPodAutoscaler`, uses `reconcileResource`/`deleteOwnedResource` helpers\n- **`deployment.go` update** (`internal/controller/deployment.go`): Skip setting `spec.replicas` on Deployment when autoscaling is active\n- **RBAC marker** (`internal/controller/memcached_controller.go`): `+kubebuilder:rbac:groups=autoscaling,resources=horizontalpodautoscalers,verbs=get;list;watch;create;update;patch;delete`\n- **Metrics** (`internal/metrics/metrics.go`): HPA reconciliation counter added to existing per-resource metrics\n- **Sample CR** (`config/samples/memcached_v1alpha1_autoscaling.yaml`): Example with autoscaling block enabled"
}