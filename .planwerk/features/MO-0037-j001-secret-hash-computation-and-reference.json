{
  "feature_id": "MO-0037",
  "title": "J001: Secret hash computation and reference resolution",
  "slug": "j001-secret-hash-computation-and-reference",
  "status": "proposed",
  "phase": null,
  "summary": "",
  "description": "**Size:** ðŸ“¦ medium\n**Category:** backend\n**Priority:** critical\n**Source:** Proposed for 'Secret Rotation & Rolling Restart\n\n  Automatic'\n\nCreate `internal/controller/secret.go` with three core functions:\n\n1. `computeSecretHash(secrets ...*corev1.Secret) string` â€” SHA-256 over sorted `.data` keys/values from all referenced Secrets. Must be deterministic and order-independent (sort Secret names, then sort keys within each Secret).\n\n2. `fetchReferencedSecrets(ctx context.Context, client client.Client, mc *v1alpha1.Memcached) ([]*corev1.Secret, []string)` â€” Resolves `SASLSpec.CredentialsSecretRef` and `TLSSpec.CertificateSecretRef` from the Memcached CR. Returns found Secrets and a list of missing Secret names.\n\n3. `mapSecretToMemcached(ctx context.Context, client client.Client) handler.MapFunc` â€” Returns the `EnqueueRequestsFromMapFunc` handler. Lists all Memcached CRs in the Secret's namespace, filters those whose `SASLSpec.CredentialsSecretRef` or `TLSSpec.CertificateSecretRef` match the changed Secret's name, returns `[]reconcile.Request` for matching CRs.\n\nCreate `internal/controller/secret_test.go` with unit tests:\n- Hash determinism (same input â†’ same output)\n- Hash order-independence (secrets in any order â†’ same hash)\n- Hash changes when Secret data changes\n- Empty secrets list returns empty/zero hash\n- `fetchReferencedSecrets` returns found + missing lists correctly\n- `mapSecretToMemcached` only enqueues CRs that actually reference the changed Secret\n- `mapSecretToMemcached` returns empty list for unreferenced Secrets\n\n**Rationale:** Foundation layer that all other features depend on. The hash computation is the core mechanism for detecting Secret changes, and the map function is required for the Secret watch. Without this, no automatic rotation detection is possible â€” users must manually restart Pods after Secret rotation, risking stale credentials/certificates in production.\n\n**Affected Areas:**\n- internal/controller/secret.go\n- internal/controller/secret_test.go",
  "stories": [],
  "requirements": [],
  "tasks": [],
  "test_specifications": [],
  "affected_files": [],
  "similar_patterns": [],
  "review_criteria": [],
  "implementation_notes": "",
  "status_history": {
    "proposed": {
      "github_account": "berendt",
      "timestamp": "2026-02-21T15:48:10.848908"
    }
  },
  "elaboration": "\n\nLet me explore the codebase to ground this elaboration in existing patterns and terminology.Serena's language server isn't initialized â€” I'll fall back to direct file reads to ground the elaboration.Now let me check the existing reconcile helper and test patterns.Now I have full codebase context. Here is the refined elaboration:\n\n---\n\n**Size:** ðŸ”¨ medium\n**Category:** backend\n**Priority:** high\n\n## Summary\n\nExtend the Memcached controller to detect changes in referenced SASL and TLS Secrets by computing a SHA-256 hash over their `.data` and storing it as a Pod template annotation (`memcached.c5c3.io/secret-hash`). When the hash changes, the Deployment's Pod template is updated, triggering a Kubernetes rolling restart. A Secret watch via `handler.EnqueueRequestsFromMapFunc` maps Secret change events back to referencing Memcached CRs. A manual restart annotation (`memcached.c5c3.io/restart-trigger`) on the CR provides user-initiated restarts. Missing Secrets are reported via a `Degraded` condition with reason `SecretNotFound`.\n\n## Scope\n\n**Included:**\n- SHA-256 hash computation over referenced SASL + TLS Secret `.data` fields\n- Pod template annotation `memcached.c5c3.io/secret-hash` carrying the combined hash\n- Secret watcher in `SetupWithManager` using `.Watches(&corev1.Secret{}, handler.EnqueueRequestsFromMapFunc(mapFunc))` to map Secret events to owning Memcached CRs\n- Manual restart annotation `memcached.c5c3.io/restart-trigger` read from the Memcached CR and propagated into Pod template annotations\n- `Degraded` condition with reason `SecretNotFound` when a referenced Secret is missing (Deployment still reconciled â€” Kubernetes handles pod-level failures)\n- Unit tests for hash computation, annotation propagation, and map function\n- Integration tests for rolling restart on Secret change and Degraded condition on missing Secret\n\n**Excluded (YAGNI):**\n- Automatic Secret creation or rotation (external concern, e.g. cert-manager)\n- Secret content validation beyond existence (e.g. checking TLS cert validity, SASL password format)\n- Metrics for Secret rotation events\n- Webhook validation of Secret references\n\n## Visualization\n\n```mermaid\nflowchart TD\n    subgraph Watch\n        SEC[\"Secret Change Event\"] --> MAP[\"EnqueueRequestsFromMapFunc\"]\n        MAP --> |\"list MCs referencing Secret\"| RECON[\"Reconcile Memcached\"]\n        MC_CHANGE[\"Memcached CR Change\"] --> RECON\n    end\n\n    subgraph Reconcile\n        RECON --> FETCH[\"Fetch referenced Secrets\"]\n        FETCH --> |\"Secret missing\"| DEG[\"Set Degraded condition\\nreason: SecretNotFound\"]\n        DEG --> DEPLOY\n        FETCH --> |\"Secrets found\"| HASH[\"SHA-256 hash over\\nSASL + TLS Secret .data\"]\n        HASH --> ANN[\"Set Pod template annotation\\nmemcached.c5c3.io/secret-hash\"]\n        ANN --> TRIGGER[\"Read restart-trigger\\nfrom CR annotation\"]\n        TRIGGER --> DEPLOY[\"Update Deployment via\\nreconcileResource\"]\n        DEPLOY --> |\"hash or trigger changed\"| ROLL[\"Rolling Update\"]\n    end\n```\n\n```mermaid\nsequenceDiagram\n    participant S as Secret\n    participant W as Secret Watcher\n    participant C as Controller\n    participant D as Deployment\n    participant P as Pods\n\n    S->>W: Secret .data updated\n    W->>C: Enqueue referencing Memcached CR\n    C->>S: Get Secret, compute SHA-256\n    C->>D: Update Pod template annotation\n    D->>P: Rolling restart with new Pods\n    P->>P: Mount updated Secret volumes\n```\n\n## Key Components\n\n- **`internal/controller/secret.go`** (new): `computeSecretHash(secrets ...*corev1.Secret) string` â€” SHA-256 over sorted `.data` keys/values; `fetchReferencedSecrets(ctx, client, mc) ([]*corev1.Secret, []string)` â€” returns found Secrets + list of missing Secret names; `mapSecretToMemcached(ctx, client, secret) []reconcile.Request` â€” the `EnqueueRequestsFromMapFunc` handler that lists all Memcached CRs in the Secret's namespace and filters those referencing the Secret via `SASLSpec.CredentialsSecretRef` or `TLSSpec.CertificateSecretRef`\n- **`internal/controller/deployment.go`** (modify `constructDeployment`): Accept a `secretHash string` and `restartTrigger string` parameter; set `dep.Spec.Template.ObjectMeta.Annotations[\"memcached.c5c3.io/secret-hash\"]` and `[\"memcached.c5c3.io/restart-trigger\"]` on the Pod template â€” this is the mechanism that triggers the rolling update\n- **`internal/controller/memcached_controller.go`** (modify): Call `fetchReferencedSecrets` + `computeSecretHash` in `reconcileDeployment` before calling `constructDeployment`; read `memcached.c5c3.io/restart-trigger` from `mc.Annotations`; extend `SetupWithManager` with `.Watches(&corev1.Secret{}, handler.EnqueueRequestsFromMapFunc(mapSecretToMemcached))`\n- **`internal/controller/status.go`** (modify): Add `ConditionReasonSecretNotFound = \"SecretNotFound\"` constant; extend `computeConditions` to accept a `missingSecrets []string` parameter â€” when non-empty, set `Degraded=True` with reason `SecretNotFound` and a message listing the missing Secret names\n- **`api/v1alpha1/memcached_types.go`** (no change): Existing `SASLSpec.CredentialsSecretRef` and `TLSSpec.CertificateSecretRef` already provide the references needed; `memcached.c5c3.io/restart-trigger` lives as a CR annotation, no type change required\n- **`internal/controller/secret_test.go`** (new): Unit tests for `computeSecretHash` (deterministic, order-independent), `mapSecretToMemcached` (correct filtering), `fetchReferencedSecrets` (found vs missing)\n- **`internal/controller/deployment_test.go`** (modify): Add cases for secret-hash and restart-trigger annotations on Pod template\n- **`internal/controller/status_test.go`** (modify): Add cases for `SecretNotFound` Degraded condition"
}